{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/dash/DashTransaction.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/dash/DashTransaction.ts"],"names":[],"mappings":";;;AAAA,+DAA2E;AAC3E,iDAA+D;AAE/D,wDAAmE;AACnE,6CAAiD;AAEjD,MAAa,eAA0D,SAAQ,iCAAwB;IAYrG,YAAY,OAAgB,EAAE,EAAiC,EAAE,UAAgC;QAC/F,KAAK,CAAC,OAAO,EAAE,EAAE,EAAE,UAAU,CAAC,CAAC;QAJ1B,SAAI,GAAG,CAAC,CAAC;QAMd,IAAI,CAAC,IAAA,iBAAM,EAAC,OAAO,CAAC,EAAE,CAAC;YACrB,MAAM,IAAI,KAAK,CAAC,iBAAiB,CAAC,CAAC;QACrC,CAAC;QAED,IAAI,EAAE,EAAE,CAAC;YACP,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,CAAC;YAE1B,IAAI,EAAE,YAAY,eAAe,EAAE,CAAC;gBAClC,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC,IAAI,CAAC;gBACpB,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC,YAAY,CAAC;YACtC,CAAC;QACH,CAAC;QAED,iEAAiE;QAChE,IAAY,CAAC,UAAU,GAAG,IAAI,CAAC,wBAAwB,CAAC;IAC3D,CAAC;IAES,MAAM,CAAC,cAAc,CAC7B,OAAgB,EAChB,WAA8C,EAC9C,UAAgC;QAEhC,OAAO,IAAI,eAAe,CAAU,OAAO,EAAE,WAAW,EAAE,UAAU,CAAC,CAAC;IACxE,CAAC;IAED,MAAM,CAAC,UAAU,CACf,MAAc,EACd,QAAiB,EACjB,aAAkC,QAAQ,EAC1C,OAAgB;QAEhB,MAAM,EAAE,GAAG,IAAI,eAAe,CAAU,OAAO,EAAE,KAAK,CAAC,UAAU,CAAU,MAAM,EAAE,IAAI,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,CAAC;QAC/G,EAAE,CAAC,IAAI,GAAG,EAAE,CAAC,OAAO,IAAI,EAAE,CAAC;QAC3B,EAAE,CAAC,OAAO,GAAG,EAAE,CAAC,OAAO,GAAG,MAAM,CAAC;QACjC,IAAI,EAAE,CAAC,UAAU,EAAE,KAAK,MAAM,CAAC,MAAM,EAAE,CAAC;YACtC,MAAM,YAAY,GAAG,IAAI,0BAAY,CAAC,MAAM,EAAE,EAAE,CAAC,UAAU,EAAE,CAAC,CAAC;YAC/D,EAAE,CAAC,YAAY,GAAG,YAAY,CAAC,YAAY,EAAE,CAAC;QAChD,CAAC;QACD,OAAO,EAAE,CAAC;IACZ,CAAC;IAED,KAAK,CAAwC,UAAgC;QAC3E,OAAO,IAAI,eAAe,CAAM,IAAI,CAAC,OAAO,EAAE,IAAI,EAAE,UAAU,CAAC,CAAC;IAClE,CAAC;IAED,UAAU,CAAC,cAAwB;QACjC,OAAO,KAAK,CAAC,UAAU,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,IAAA,8BAAY,EAAC,IAAI,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IACtG,CAAC;IAED;;;;;;;;;OASG;IACK,wBAAwB,CAAC,MAAe,EAAE,aAAsB,EAAE,cAAc,GAAG,KAAK;QAC9F,4EAA4E;QAC5E,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,MAAM,GAAG,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;QACtD,CAAC;QAED,IAAI,aAAa,KAAK,SAAS,IAAI,aAAa,KAAK,CAAC,EAAE,CAAC;YACvD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;QACnC,CAAC;QAED,gDAAgD;QAChD,gFAAgF;QAChF,MAAM,UAAU,GAAI,2BAAW,CAAC,SAAiB,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACxE,UAAU,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAExB,gEAAgE;QAChE,MAAM,YAAY,GAAG,IAAI,0BAAY,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACjD,YAAY,CAAC,WAAW,CAAC,CAAC,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,CAAC;QAEtE,8DAA8D;QAC9D,iFAAiF;QACjF,mCAAmC;QACnC,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACtB,YAAY,CAAC,MAAM,GAAG,2BAAW,CAAC,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAClE,YAAY,CAAC,aAAa,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAChD,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,OAAO,CAAC,UAAoB;QAC1B,IAAI,UAAU,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;QACtC,CAAC;QACD,OAAO,sBAAO,CAAC,OAAO,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;IAC1C,CAAC;IAED;;;;OAIG;IACH,cAAc,CAAC,QAAgB;QAC7B,IAAI,CAAC,CAAC,QAAQ,GAAG,iCAAe,CAAC,oBAAoB,CAAC,EAAE,CAAC;YACvD,MAAM,YAAY,GAAG,IAAI,0BAAY,CAAC,MAAM,CAAC,WAAW,CAAC,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC;YAEhF,IAAI,CAAC,GAAG,CAAC,OAAO,CAAC,UAAU,IAAI;gBAC7B,YAAY,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;gBACnC,YAAY,CAAC,WAAW,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;YACvC,CAAC,CAAC,CAAC;YAEH,OAAO,sBAAO,CAAC,OAAO,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC;QAC9C,CAAC;QAED,OAAO,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;IAC7B,CAAC;;AAjIH,0CAkIC;AAjIQ,2BAAW,GAAG,CAAC,AAAJ,CAAK;AAChB,sCAAsB,GAAG,CAAC,AAAJ,CAAK;AAC3B,4CAA4B,GAAG,CAAC,AAAJ,CAAK;AACjC,8CAA8B,GAAG,CAAC,AAAJ,CAAK;AACnC,2CAA2B,GAAG,CAAC,AAAJ,CAAK;AAChC,6BAAa,GAAG,CAAC,AAAJ,CAAK;AAClB,sCAAsB,GAAG,CAAC,AAAJ,CAAK","sourcesContent":["import { BufferReader, BufferWriter } from 'bitcoinjs-lib/src/bufferutils';\nimport { crypto as bcrypto, Transaction } from 'bitcoinjs-lib';\n\nimport { UtxoTransaction, varSliceSize } from '../UtxoTransaction';\nimport { isDash, Network } from '../../networks';\n\nexport class DashTransaction<TNumber extends number | bigint = number> extends UtxoTransaction<TNumber> {\n  static DASH_NORMAL = 0;\n  static DASH_PROVIDER_REGISTER = 1;\n  static DASH_PROVIDER_UPDATE_SERVICE = 2;\n  static DASH_PROVIDER_UPDATE_REGISTRAR = 3;\n  static DASH_PROVIDER_UPDATE_REVOKE = 4;\n  static DASH_COINBASE = 5;\n  static DASH_QUORUM_COMMITMENT = 6;\n\n  public type = 0;\n  public extraPayload?: Buffer;\n\n  constructor(network: Network, tx?: Transaction<bigint | number>, amountType?: 'bigint' | 'number') {\n    super(network, tx, amountType);\n\n    if (!isDash(network)) {\n      throw new Error(`invalid network`);\n    }\n\n    if (tx) {\n      this.version = tx.version;\n\n      if (tx instanceof DashTransaction) {\n        this.type = tx.type;\n        this.extraPayload = tx.extraPayload;\n      }\n    }\n\n    // since `__toBuffer` is private we have to do a little hack here\n    (this as any).__toBuffer = this.toBufferWithExtraPayload;\n  }\n\n  protected static newTransaction<TNumber extends number | bigint = number>(\n    network: Network,\n    transaction?: DashTransaction<number | bigint>,\n    amountType?: 'number' | 'bigint'\n  ): DashTransaction<TNumber> {\n    return new DashTransaction<TNumber>(network, transaction, amountType);\n  }\n\n  static fromBuffer<TNumber extends number | bigint = number>(\n    buffer: Buffer,\n    noStrict: boolean,\n    amountType: 'number' | 'bigint' = 'number',\n    network: Network\n  ): DashTransaction<TNumber> {\n    const tx = new DashTransaction<TNumber>(network, super.fromBuffer<TNumber>(buffer, true, amountType, network));\n    tx.type = tx.version >> 16;\n    tx.version = tx.version & 0xffff;\n    if (tx.byteLength() !== buffer.length) {\n      const bufferReader = new BufferReader(buffer, tx.byteLength());\n      tx.extraPayload = bufferReader.readVarSlice();\n    }\n    return tx;\n  }\n\n  clone<TN2 extends bigint | number = TNumber>(amountType?: 'number' | 'bigint'): DashTransaction<TN2> {\n    return new DashTransaction<TN2>(this.network, this, amountType);\n  }\n\n  byteLength(_ALLOW_WITNESS?: boolean): number {\n    return super.byteLength(_ALLOW_WITNESS) + (this.extraPayload ? varSliceSize(this.extraPayload) : 0);\n  }\n\n  /**\n   * Helper to override `__toBuffer()` of bitcoinjs.Transaction.\n   * Since the method is private, we use a hack in the constructor to make it work.\n   *\n   * TODO: remove `private` modifier in bitcoinjs `__toBuffer()` or find some other solution\n   *\n   * @param buffer - optional target buffer\n   * @param initialOffset - can only be undefined or 0. Other values are only used for serialization in blocks.\n   * @param _ALLOW_WITNESS - ignored\n   */\n  private toBufferWithExtraPayload(buffer?: Buffer, initialOffset?: number, _ALLOW_WITNESS = false): Buffer {\n    // We can ignore the `_ALLOW_WITNESS` parameter here since it has no effect.\n    if (!buffer) {\n      buffer = Buffer.allocUnsafe(this.byteLength(false));\n    }\n\n    if (initialOffset !== undefined && initialOffset !== 0) {\n      throw new Error(`not supported`);\n    }\n\n    // Start out with regular bitcoin byte sequence.\n    // This buffer will have excess size because it uses `byteLength()` to allocate.\n    const baseBuffer = (Transaction.prototype as any).__toBuffer.call(this);\n    baseBuffer.copy(buffer);\n\n    // overwrite leading version bytes (uint16 version, uint16 type)\n    const bufferWriter = new BufferWriter(buffer, 0);\n    bufferWriter.writeUInt32((this.version & 0xffff) | (this.type << 16));\n\n    // Seek to end of original byte sequence and add extraPayload.\n    // We must use the byteLength as calculated by the bitcoinjs implementation since\n    // `baseBuffer` has an excess size.\n    if (this.extraPayload) {\n      bufferWriter.offset = Transaction.prototype.byteLength.call(this);\n      bufferWriter.writeVarSlice(this.extraPayload);\n    }\n\n    return buffer;\n  }\n\n  getHash(forWitness?: boolean): Buffer {\n    if (forWitness) {\n      throw new Error(`invalid argument`);\n    }\n    return bcrypto.hash256(this.toBuffer());\n  }\n\n  /**\n   * Build a hash for all or none of the transaction inputs depending on the hashtype\n   * @param hashType\n   * @returns Buffer\n   */\n  getPrevoutHash(hashType: number): Buffer {\n    if (!(hashType & UtxoTransaction.SIGHASH_ANYONECANPAY)) {\n      const bufferWriter = new BufferWriter(Buffer.allocUnsafe(36 * this.ins.length));\n\n      this.ins.forEach(function (txIn) {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n\n      return bcrypto.hash256(bufferWriter.buffer);\n    }\n\n    return Buffer.alloc(32, 0);\n  }\n}\n"]}
{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/wallet/psbt/RootNodes.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/wallet/psbt/RootNodes.ts"],"names":[],"mappings":";AAAA;;GAEG;;;AA8BH,oDAOC;AAwGD,sCAKC;AAOD,gDAIC;AA3JD,iCAAiC;AACjC,uCAAuC;AAGvC,uCAA+C;AAC/C,iCAAqD;AACrD,kDAAmD;AAGnD,uDAA6D;AAE7D,mDAAgE;AAChE,kCAAoE;AAEpE;;KAEK;AACL,MAAa,yBAA0B,SAAQ,KAAK;IAClD,YAAY,OAAe;QACzB,KAAK,CAAC,OAAO,CAAC,CAAC;IACjB,CAAC;CACF;AAJD,8DAIC;AAED;;;;GAIG;AACH,SAAgB,oBAAoB,CAAC,IAAc;IACjD,MAAM,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAC1D,IAAA,oBAAY,EAAC,eAAM,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,MAAM,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC,CACvE,CAAC;IACF,MAAM,CAAC,CAAC,MAAM,IAAI,IAAA,gBAAQ,EAAC,MAAM,CAAC,EAAE,wDAAwD,MAAM,EAAE,MAAM,EAAE,CAAC,CAAC;IAC9G,aAAa;IACb,OAAO,MAAM,CAAC;AAChB,CAAC;AAED;;;;GAIG;AACH,SAAS,aAAa,CAAC,EACrB,OAAO,EACP,IAAI,EACJ,YAAY,EACZ,gBAAgB,EAChB,OAAO,GAOR;IACC,MAAM,WAAW,GAAmB,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3F,MAAM,WAAW,GAAG,IAAA,wBAAiB,EAAC,gBAAgB,CAAC,CAAC;IACxD,OAAO,WAAW,CAAC,IAAI,CAAC,CAAC,UAAU,EAAE,EAAE,CACrC,IAAA,sCAAsB,EAAC,WAAW,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,YAAY,CAAC,CAC3F,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,SAAS,sBAAsB,CAC7B,OAAuB,EACvB,YAAoB,EACpB,gBAAsC,EACtC,OAAgB;IAEhB,MAAM,YAAY,GAA0B;QAC1C,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;QACT,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;KACV,CAAC;IAEF,MAAM,KAAK,GAAG,YAAY,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,aAAa,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,YAAY,EAAE,gBAAgB,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC;IACrH,MAAM,CAAC,KAAK,EAAE,oDAAoD,CAAC,CAAC;IACpE,OAAO,KAAK,CAAC;AACf,CAAC;AAED;;;;GAIG;AACH,SAAS,yBAAyB,CAAC,IAAc;IAK/C,SAAS,eAAe,CAAC,KAAgB,EAAE,YAAoB;QAC7D,MAAM,YAAY,GAChB,KAAK,CAAC,WAAW,EAAE,MAAM;YACzB,CAAC,KAAK,CAAC,cAAc;gBACnB,CAAC,CAAC,IAAA,yCAA2B,EAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,OAAO,EAAE,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC,CAAC,IAAI,CAAC,YAAY,CAAC;qBACzG,MAAM;gBACX,CAAC,CAAC,SAAS,CAAC,CAAC;QACjB,MAAM,CAAC,YAAY,EAAE,qCAAqC,CAAC,CAAC;QAC5D,OAAO,YAAY,CAAC;IACtB,CAAC;IAED,SAAS,iBAAiB,CAAC,KAAgB;QACzC,MAAM,OAAO,GAAG,KAAK,EAAE,eAAe,IAAI,KAAK,EAAE,kBAAkB,CAAC;QACpE,MAAM,CAAC,OAAO,EAAE,MAAM,EAAE,wCAAwC,CAAC,CAAC;QAClE,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;IACzB,CAAC;IAED,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;IAE/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACjD,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAClC,MAAM,gBAAgB,GAAG,IAAA,6BAAsB,EAAC,KAAK,CAAC,CAAC;QACvD,IAAI,gBAAgB,KAAK,UAAU,EAAE,CAAC;YACpC,SAAS;QACX,CAAC;QACD,MAAM,YAAY,GAAG,eAAe,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAC/D,MAAM,cAAc,GAAG,iBAAiB,CAAC,KAAK,CAAC,CAAC;QAChD,OAAO,EAAE,gBAAgB,EAAE,YAAY,EAAE,cAAc,EAAE,CAAC;IAC5D,CAAC;IAED,MAAM,IAAI,yBAAyB,CAAC,0BAA0B,CAAC,CAAC;AAClE,CAAC;AAED;;;;;GAKG;AACH,SAAgB,aAAa,CAAC,IAAc,EAAE,SAAiC;IAC7E,MAAM,EAAE,gBAAgB,EAAE,YAAY,EAAE,cAAc,EAAE,GAAG,yBAAyB,CAAC,IAAI,CAAC,CAAC;IAC3F,MAAM,OAAO,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC,SAAS,CAAmB,CAAC;IAC7G,MAAM,KAAK,GAAG,sBAAsB,CAAC,OAAO,EAAE,YAAY,EAAE,gBAAgB,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;IAC5F,OAAO,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,SAAS,CAAC,CAAC,CAAC,CAA2B,CAAC;AAClE,CAAC;AAED;;;;GAIG;AACH,SAAgB,kBAAkB,CAAC,IAAc;IAC/C,MAAM,iBAAiB,GAAG,oBAAoB,CAAC,IAAI,CAAC,CAAC;IACrD,MAAM,CAAC,iBAAiB,EAAE,mCAAmC,CAAC,CAAC;IAC/D,OAAO,aAAa,CAAC,IAAI,EAAE,iBAAiB,CAAC,CAAC;AAChD,CAAC","sourcesContent":["/**\n * Contains helper methods for getting and sorting root nodes from a PSBT.\n */\n\nimport * as assert from 'assert';\nimport * as bs58check from 'bs58check';\n\nimport { UtxoPsbt } from '../../UtxoPsbt';\nimport { isTriple, Triple } from '../../types';\nimport { BIP32Factory, BIP32Interface } from 'bip32';\nimport { ecc as eccLib } from '../../../noble_ecc';\nimport { ParsedScriptType2Of3 } from '../../parseInput';\nimport { Network } from '../../../networks';\nimport { createOutputScript2of3 } from '../../outputScripts';\nimport { PsbtInput } from 'bip174/src/lib/interfaces';\nimport { createTransactionFromBuffer } from '../../transaction';\nimport { getPsbtInputScriptType, toScriptType2Of3s } from '../Psbt';\n\n/**\n * Error thrown when no multi-sig input is found in a PSBT.\n * */\nexport class ErrorNoMultiSigInputFound extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\n/**\n * Retrieves unsorted root BIP32Interface nodes from a PSBT if available.\n * @param psbt - The PSBT from which to extract the global Xpubs.\n * @returns An array of BIP32Interface objects or undefined if not available.\n */\nexport function getUnsortedRootNodes(psbt: UtxoPsbt): Triple<BIP32Interface> | undefined {\n  const bip32s = psbt.data.globalMap.globalXpub?.map((xpub) =>\n    BIP32Factory(eccLib).fromBase58(bs58check.encode(xpub.extendedPubkey))\n  );\n  assert(!bip32s || isTriple(bip32s), `Invalid globalXpubs in PSBT. Expected 3 or none. Got ${bip32s?.length}`);\n  // @ts-ignore\n  return bip32s;\n}\n\n/**\n * Determines if the given public keys' permutation matches a specified script.\n * @param params - Object containing public keys, permutation, script public key, script type, and network.\n * @returns A boolean indicating if the permutation matches the script.\n */\nfunction matchesScript({\n  pubKeys,\n  perm,\n  scriptPubKey,\n  parsedScriptType,\n  network,\n}: {\n  pubKeys: Buffer[];\n  perm: Triple<number>;\n  scriptPubKey: Buffer;\n  parsedScriptType: ParsedScriptType2Of3;\n  network: Network;\n}): boolean {\n  const pubKeysPerm: Triple<Buffer> = [pubKeys[perm[0]], pubKeys[perm[1]], pubKeys[perm[2]]];\n  const scriptTypes = toScriptType2Of3s(parsedScriptType);\n  return scriptTypes.some((scriptType) =>\n    createOutputScript2of3(pubKeysPerm, scriptType, network).scriptPubKey.equals(scriptPubKey)\n  );\n}\n\n/**\n * Finds the correct order of public keys to match a given script.\n * @param pubKeys - Array of public keys involved in the script.\n * @param scriptPubKey - The script public key to match against.\n * @param parsedScriptType - The parsed script type.\n * @param network - Bitcoin network.\n * @returns The order of public keys that match the script.\n */\nfunction findSortOrderOfPubKeys(\n  pubKeys: Triple<Buffer>,\n  scriptPubKey: Buffer,\n  parsedScriptType: ParsedScriptType2Of3,\n  network: Network\n): Triple<number> {\n  const permutations: Array<Triple<number>> = [\n    [0, 1, 2],\n    [0, 2, 1],\n    [1, 0, 2],\n    [1, 2, 0],\n    [2, 0, 1],\n    [2, 1, 0],\n  ];\n\n  const order = permutations.find((perm) => matchesScript({ pubKeys, perm, scriptPubKey, parsedScriptType, network }));\n  assert(order, 'Could not find sort order of multi sig public keys');\n  return order;\n}\n\n/**\n * Extracts multi-sig input data, including script type, script public key, and derivation path, from the first relevant PSBT input.\n * @param psbt - The PSBT to extract data from.\n * @returns An object containing the parsed script type, script public key, and derivation path.\n */\nfunction getFirstMultiSigInputData(psbt: UtxoPsbt): {\n  parsedScriptType: ParsedScriptType2Of3;\n  scriptPubKey: Buffer;\n  derivationPath: string;\n} {\n  function getScriptPubKey(input: PsbtInput, prevOutIndex: number) {\n    const scriptPubKey =\n      input.witnessUtxo?.script ??\n      (input.nonWitnessUtxo\n        ? createTransactionFromBuffer(input.nonWitnessUtxo, psbt.network, { amountType: 'bigint' }).outs[prevOutIndex]\n            .script\n        : undefined);\n    assert(scriptPubKey, 'Input scriptPubKey can not be found');\n    return scriptPubKey;\n  }\n\n  function getDerivationPath(input: PsbtInput) {\n    const bip32Dv = input?.bip32Derivation ?? input?.tapBip32Derivation;\n    assert(bip32Dv?.length, 'Input Bip32Derivation can not be found');\n    return bip32Dv[0].path;\n  }\n\n  const txInputs = psbt.txInputs;\n\n  for (let i = 0; i < psbt.data.inputs.length; i++) {\n    const input = psbt.data.inputs[i];\n    const parsedScriptType = getPsbtInputScriptType(input);\n    if (parsedScriptType === 'p2shP2pk') {\n      continue;\n    }\n    const scriptPubKey = getScriptPubKey(input, txInputs[i].index);\n    const derivationPath = getDerivationPath(input);\n    return { parsedScriptType, scriptPubKey, derivationPath };\n  }\n\n  throw new ErrorNoMultiSigInputFound('No multi sig input found');\n}\n\n/**\n * Sorts given root nodes based on the script compatibility with the PSBT's multi-sig inputs.\n * @param psbt - The PSBT containing multi-sig inputs.\n * @param rootNodes - Array of root nodes to sort.\n * @returns An array of BIP32Interface objects in the order that matches the multi-sig script.\n */\nexport function sortRootNodes(psbt: UtxoPsbt, rootNodes: Triple<BIP32Interface>): Triple<BIP32Interface> {\n  const { parsedScriptType, scriptPubKey, derivationPath } = getFirstMultiSigInputData(psbt);\n  const pubKeys = rootNodes.map((rootNode) => rootNode.derivePath(derivationPath).publicKey) as Triple<Buffer>;\n  const order = findSortOrderOfPubKeys(pubKeys, scriptPubKey, parsedScriptType, psbt.network);\n  return order.map((i) => rootNodes[i]) as Triple<BIP32Interface>;\n}\n\n/**\n * Retrieves sorted root nodes from a PSBT, ensuring they are ordered according to script compatibility.\n * @param psbt - The PSBT to extract and sort root nodes from.\n * @returns An array of sorted BIP32Interface root nodes.\n */\nexport function getSortedRootNodes(psbt: UtxoPsbt): Triple<BIP32Interface> {\n  const unsortedRootNodes = getUnsortedRootNodes(psbt);\n  assert(unsortedRootNodes, 'Could not find root nodes in PSBT');\n  return sortRootNodes(psbt, unsortedRootNodes);\n}\n"]}
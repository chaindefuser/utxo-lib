{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/taproot.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/taproot.ts"],"names":[],"mappings":"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","sourcesContent":["// Taproot-specific key aggregation and taptree logic as defined in:\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n// https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki\n\nimport { TapTree as PsbtTapTree, TapLeaf as PsbtTapLeaf } from 'bip174/src/lib/interfaces';\nimport assert = require('assert');\nimport FastPriorityQueue = require('fastpriorityqueue');\nimport { script as bscript, crypto as bcrypto, payments as bpayments } from 'bitcoinjs-lib';\nimport { ecc as eccLib } from './noble_ecc';\nconst varuint = require('varuint-bitcoin');\n\n/**\n * The 0x02 prefix indicating an even Y coordinate which is implicitly assumed\n * on all 32 byte x-only pub keys as defined in BIP340.\n */\nexport const EVEN_Y_COORD_PREFIX = Buffer.of(0x02);\nexport const INITIAL_TAPSCRIPT_VERSION = 0xc0;\n\nexport interface TinySecp256k1Interface {\n  isXOnlyPoint(p: Uint8Array): boolean;\n  xOnlyPointAddTweak(p: Uint8Array, tweak: Uint8Array): XOnlyPointAddTweakResult | null;\n  pointFromScalar(sk: Uint8Array, compressed?: boolean): Uint8Array | null;\n  pointMultiply(a: Uint8Array, b: Uint8Array): Uint8Array | null;\n  pointAdd(a: Uint8Array, b: Uint8Array): Uint8Array | null;\n  privateAdd(d: Uint8Array, tweak: Uint8Array): Uint8Array | null;\n  privateNegate(d: Uint8Array): Uint8Array;\n}\n\n/**\n * Aggregates a list of public keys into a single MuSig2* public key\n * according to the MuSig2 paper.\n * @param ecc Elliptic curve implementation\n * @param pubkeys The list of pub keys to aggregate\n * @returns a 32 byte Buffer representing the aggregate key\n */\nexport function aggregateMuSigPubkeys(ecc: TinySecp256k1Interface, pubkeys: Buffer[]): Uint8Array {\n  // TODO: Consider enforcing key uniqueness.\n  assert(pubkeys.length > 1, 'at least two pubkeys are required for musig key aggregation');\n\n  // Sort the keys in ascending order\n  pubkeys.sort(Buffer.compare);\n\n  // In MuSig all signers contribute key material to a single signing key,\n  // using the equation\n  //\n  //     P = sum_i µ_i * P_i\n  //\n  // where `P_i` is the public key of the `i`th signer and `µ_i` is a so-called\n  // _MuSig coefficient_ computed according to the following equation\n  //\n  // L = H(P_1 || P_2 || ... || P_n)\n  // µ_i = H(L || P_i)\n\n  const L = bcrypto.taggedHash('KeyAgg list', Buffer.concat(pubkeys));\n\n  const secondUniquePubkey = pubkeys.find((pubkey) => !pubkeys[0].equals(pubkey));\n\n  const tweakedPubkeys: Uint8Array[] = pubkeys.map((pubkey) => {\n    const xyPubkey = Buffer.concat([EVEN_Y_COORD_PREFIX, pubkey]);\n\n    if (secondUniquePubkey !== undefined && secondUniquePubkey.equals(pubkey)) {\n      // The second unique key in the pubkey list given to ''KeyAgg'' (as well\n      // as any keys identical to this key) gets the constant KeyAgg\n      // coefficient 1 which saves an exponentiation (see the MuSig2* appendix\n      // in the MuSig2 paper).\n      return xyPubkey;\n    }\n\n    const c = bcrypto.taggedHash('KeyAgg coefficient', Buffer.concat([L, pubkey]));\n\n    const tweakedPubkey = ecc.pointMultiply(xyPubkey, c);\n    if (!tweakedPubkey) {\n      throw new Error('Failed to multiply pubkey by coefficient');\n    }\n    return tweakedPubkey;\n  });\n  const aggregatePubkey = tweakedPubkeys.reduce((prev, curr) => {\n    const next = ecc.pointAdd(prev, curr);\n    if (!next) throw new Error('Failed to sum pubkeys');\n    return next;\n  });\n\n  return aggregatePubkey.slice(1);\n}\n\n/**\n * Encodes the length of a script as a bitcoin variable length integer.\n * @param script\n * @returns\n */\nexport function serializeScriptSize(script: Buffer): Buffer {\n  return varuint.encode(script.length);\n}\n\n/**\n * Gets a tapleaf tagged hash from a script.\n * @param script\n * @returns\n */\nexport function hashTapLeaf(script: Buffer, leafVersion = INITIAL_TAPSCRIPT_VERSION): Buffer {\n  const size = serializeScriptSize(script);\n  return bcrypto.taggedHash('TapLeaf', Buffer.concat([Buffer.of(leafVersion), size, script]));\n}\n\n/**\n * Creates a lexicographically sorted tapbranch from two child taptree nodes\n * and returns its tagged hash.\n * @param child1\n * @param child2\n * @returns the tagged tapbranch hash\n */\nexport function hashTapBranch(child1: Buffer, child2: Buffer): Buffer {\n  // sort the children lexicographically\n  const sortedChildren = [child1, child2].sort(Buffer.compare);\n\n  return bcrypto.taggedHash('TapBranch', Buffer.concat(sortedChildren));\n}\n\nexport function calculateTapTweak(pubkey: Uint8Array, taptreeRoot?: Uint8Array): Uint8Array {\n  if (pubkey.length !== 32) {\n    throw new Error(`Invalid pubkey size ${pubkey.length}.`);\n  }\n  if (taptreeRoot) {\n    if (taptreeRoot.length !== 32) {\n      throw new Error(`Invalid taptreeRoot size ${taptreeRoot.length}.`);\n    }\n    return bcrypto.taggedHash('TapTweak', Buffer.concat([pubkey, taptreeRoot]));\n  }\n  // If the spending conditions do not require a script path, the output key should commit to an\n  // unspendable script path instead of having no script path.\n  // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-22\n  return bcrypto.taggedHash('TapTweak', Buffer.from(pubkey));\n}\n\n/**\n * Tweaks a privkey, using the tagged hash of its pubkey, and (optionally) a taptree root\n * @param ecc Elliptic curve implementation\n * @param pubkey public key, used to calculate the tweak\n * @param privkey the privkey to tweak\n * @param taptreeRoot the taptree root tagged hash\n * @returns {Buffer} the tweaked privkey\n */\nexport function tapTweakPrivkey(\n  ecc: TinySecp256k1Interface,\n  pubkey: Uint8Array,\n  privkey: Uint8Array,\n  taptreeRoot?: Uint8Array\n): Uint8Array {\n  const tapTweak = calculateTapTweak(pubkey, taptreeRoot);\n\n  const point = ecc.pointFromScalar(privkey);\n  if (!point) throw new Error('Invalid private key');\n  if (point[0] % 2 === 1) privkey = ecc.privateNegate(privkey);\n  const result = ecc.privateAdd(privkey, tapTweak);\n  if (!result) throw new Error('Invalid private key');\n  return result;\n}\n\nexport interface XOnlyPointAddTweakResult {\n  parity: 1 | 0;\n  xOnlyPubkey: Uint8Array;\n}\n\n/**\n * Tweaks an internal pubkey, using the tagged hash of itself, and (optionally) a taptree root\n * @param ecc Elliptic curve implementation\n * @param pubkey the internal pubkey to tweak\n * @param taptreeRoot the taptree root tagged hash\n * @returns {TweakedPubkey} the tweaked pubkey\n */\nexport function tapTweakPubkey(\n  ecc: TinySecp256k1Interface,\n  pubkey: Uint8Array,\n  taptreeRoot?: Buffer\n): XOnlyPointAddTweakResult {\n  const tapTweak = calculateTapTweak(pubkey, taptreeRoot);\n  const result = ecc.xOnlyPointAddTweak(pubkey, tapTweak);\n  if (!result) throw new Error('Invalid pubkey');\n  return result;\n}\n\nexport interface Taptree {\n  root: Buffer;\n  paths: Buffer[][];\n}\n\ninterface WeightedTapScript {\n  /** A TapLeaf or TapBranch tagged hash */\n  taggedHash: Buffer;\n  weight: number;\n  paths: {\n    [index: number]: Buffer[];\n  };\n}\n\nfunction recurseTaptree(leaves: Iterator<[number, PsbtTapLeaf]>, targetDepth = 0): Taptree {\n  const { value, done } = leaves.next();\n  assert(!done, 'insufficient leaves to reconstruct tap tree');\n  const [index, leaf] = value;\n  const tree: Taptree = {\n    root: hashTapLeaf(leaf.script, leaf.leafVersion),\n    paths: [],\n  };\n  tree.paths[index] = [];\n  for (let depth = leaf.depth; depth > targetDepth; depth--) {\n    const sibling = recurseTaptree(leaves, depth);\n    tree.paths.forEach((path) => path.push(sibling.root));\n    sibling.paths.forEach((path) => path.push(tree.root));\n    tree.root = hashTapBranch(tree.root, sibling.root);\n    // Merge disjoint sparse arrays of paths into tree.paths\n    Object.assign(tree.paths, sibling.paths);\n  }\n  return tree;\n}\n\n/**\n * Gets the root hash and hash-paths of a taptree from the depth-first\n * construction used in BIP-0371 PSBTs\n * @param tree\n * @returns {Taptree} the tree, represented by its root hash, and the paths to\n * that root from each of the input scripts\n */\nexport function getDepthFirstTaptree(tree: PsbtTapTree): Taptree {\n  const iter = tree.leaves.entries();\n  const ret = recurseTaptree(iter);\n  assert(iter.next().done, 'invalid tap tree, no path to some leaves');\n  return ret;\n}\n\n/**\n * Gets the root hash of a taptree using a weighted Huffman construction from a\n * list of scripts and corresponding weights.\n * @param scripts\n * @param weights\n * @returns {Taptree} the tree, represented by its root hash, and the paths to that root from each of the input scripts\n */\nexport function getHuffmanTaptree(scripts: Buffer[], weights: Array<number | undefined>): Taptree {\n  assert(scripts.length > 0, 'at least one script is required to construct a tap tree');\n\n  // Create a queue/heap of the provided scripts prioritized according to their\n  // corresponding weights.\n  const queue = new FastPriorityQueue<WeightedTapScript>((a, b): boolean => {\n    return a.weight < b.weight;\n  });\n  scripts.forEach((script, index) => {\n    const weight = weights[index] || 1;\n    assert(weight > 0, 'script weight must be a positive value');\n\n    queue.add({\n      weight,\n      taggedHash: hashTapLeaf(script),\n      paths: { [index]: [] },\n    });\n  });\n\n  // Now that we have a queue of weighted scripts, we begin a loop whereby we\n  // remove the two lowest weighted items from the queue. We create a tap branch\n  // node from the two items, and add the branch back to the queue with the\n  // combined weight of both its children. Each loop reduces the number of items\n  // in the queue by one, and we repeat until we are left with only one item -\n  // this becomes the tap tree root.\n  //\n  // For example, if we begin with scripts A, B, C, D with weights 6, 3, 1, 1\n  // After first loop: A(6), B(3), CD(1 + 1)\n  // After second loop: A(6), B[CD](3 + 2)\n  // Final loop: A[B[CD]](6+5)\n  // The final tree will look like:\n  //\n  //        A[B[CD]]\n  //       /        \\\n  //      A         B[CD]\n  //               /     \\\n  //              B      [CD]\n  //                    /    \\\n  //                   C      D\n  //\n  // This ensures that the spending conditions we believe to have the highest\n  // probability of being used are further up the tree than less likely scripts,\n  // thereby reducing the size of the merkle proofs for the more likely scripts.\n  while (queue.size > 1) {\n    // We can safely expect two polls to return non-null elements since we've\n    // checked that the queue has at least two elements before looping.\n    const child1 = queue.poll() as WeightedTapScript;\n    const child2 = queue.poll() as WeightedTapScript;\n\n    Object.values(child1.paths).forEach((path) => path.push(child2.taggedHash));\n    Object.values(child2.paths).forEach((path) => path.push(child1.taggedHash));\n\n    queue.add({\n      taggedHash: hashTapBranch(child1.taggedHash, child2.taggedHash),\n      weight: child1.weight + child2.weight,\n      paths: { ...child1.paths, ...child2.paths },\n    });\n  }\n\n  // After the while loop above completes we should have exactly one element\n  // remaining in the queue, which we can safely extract below.\n  const rootNode = queue.poll() as WeightedTapScript;\n\n  const paths = Object.entries(rootNode.paths).reduce((acc, [index, path]) => {\n    acc[Number(index)] = path; // TODO: Why doesn't TS know it's a number?\n    return acc;\n  }, Array(scripts.length));\n  return { root: rootNode.taggedHash, paths };\n}\n\nexport function getControlBlock(\n  parity: 0 | 1,\n  pubkey: Uint8Array,\n  path: Buffer[],\n  leafVersion = INITIAL_TAPSCRIPT_VERSION\n): Buffer {\n  const parityVersion = leafVersion + parity;\n\n  return Buffer.concat([Buffer.of(parityVersion), pubkey, ...path]);\n}\n\nexport interface KeyPathWitness {\n  spendType: 'Key';\n  signature: Buffer;\n  annex?: Buffer;\n}\n\nexport interface ScriptPathWitness {\n  spendType: 'Script';\n  scriptSig: Buffer[];\n  tapscript: Buffer;\n  controlBlock: Buffer;\n  annex?: Buffer;\n}\n\nexport interface ControlBlock {\n  parity: number;\n  internalPubkey: Buffer;\n  leafVersion: number;\n  path: Buffer[];\n}\n\n/**\n * Parses a taproot witness stack and extracts key data elements.\n * @param witnessStack\n * @returns {ScriptPathWitness|KeyPathWitness} an object representing the\n * parsed witness for a script path or key path spend.\n * @throws {Error} if the witness stack does not conform to the BIP 341 script validation rules\n */\nexport function parseTaprootWitness(witnessStack: Buffer[]): ScriptPathWitness | KeyPathWitness {\n  let annex;\n  if (witnessStack.length >= 2 && witnessStack[witnessStack.length - 1][0] === 0x50) {\n    // If there are at least two witness elements, and the first byte of the last element is\n    // 0x50, this last element is called annex a and is removed from the witness stack\n    annex = witnessStack[witnessStack.length - 1];\n    witnessStack = witnessStack.slice(0, -1);\n  }\n\n  if (witnessStack.length < 1) {\n    throw new Error('witness stack must have at least one element');\n  } else if (witnessStack.length === 1) {\n    // key path spend\n    const signature = witnessStack[0];\n    if (!bscript.isCanonicalSchnorrSignature(signature)) {\n      throw new Error('invalid signature');\n    }\n    return { spendType: 'Key', signature, annex };\n  }\n\n  // script path spend\n  // second to last element is the tapscript\n  const tapscript = witnessStack[witnessStack.length - 2];\n  const tapscriptChunks = bscript.decompile(tapscript);\n\n  if (!tapscriptChunks || tapscriptChunks.length === 0) {\n    throw new Error('tapscript is not a valid script');\n  }\n\n  // The last stack element is called the control block c, and must have length 33 + 32m,\n  // for a value of m that is an integer between 0 and 128, inclusive\n  const controlBlock = witnessStack[witnessStack.length - 1];\n  if (controlBlock.length < 33 || controlBlock.length > 33 + 32 * 128 || controlBlock.length % 32 !== 1) {\n    throw new Error('invalid control block length');\n  }\n\n  return {\n    spendType: 'Script',\n    scriptSig: witnessStack.slice(0, -2),\n    tapscript,\n    controlBlock,\n    annex,\n  };\n}\n\n/**\n * Parses a taproot control block.\n * @param ecc Elliptic curve implementation\n * @param controlBlock the control block to parse\n * @returns {ControlBlock} the parsed control block\n * @throws {Error} if the witness stack does not conform to the BIP 341 script validation rules\n */\nexport function parseControlBlock(ecc: TinySecp256k1Interface, controlBlock: Buffer): ControlBlock {\n  if ((controlBlock.length - 1) % 32 !== 0) {\n    throw new TypeError('Invalid control block length');\n  }\n\n  const parity = controlBlock[0] & 0x01;\n\n  // Let p = c[1:33] and let P = lift_x(int(p)) where lift_x and [:] are defined as in BIP340.\n  // Fail if this point is not on the curve\n  const internalPubkey = controlBlock.slice(1, 33);\n  if (!ecc.isXOnlyPoint(internalPubkey)) {\n    throw new Error('internal pubkey is not an EC point');\n  }\n\n  // The leaf version cannot be 0x50 as that would result in ambiguity with the annex.\n  const leafVersion = controlBlock[0] & 0xfe;\n  if (leafVersion === 0x50) {\n    throw new Error('invalid leaf version');\n  }\n\n  const path: Buffer[] = [];\n  for (let j = 33; j < controlBlock.length; j += 32) {\n    path.push(controlBlock.slice(j, j + 32));\n  }\n\n  return {\n    parity,\n    internalPubkey,\n    leafVersion,\n    path,\n  };\n}\n\n/**\n * Calculates the tapleaf hash from a control block and script.\n * @param ecc Elliptic curve implementation\n * @param controlBlock the control block, either raw or parsed\n * @param tapscript the leaf script corresdponding to the control block\n * @returns {Buffer} the tapleaf hash\n */\nexport function getTapleafHash(\n  ecc: TinySecp256k1Interface,\n  controlBlock: Buffer | ControlBlock,\n  tapscript: Buffer\n): Buffer {\n  if (Buffer.isBuffer(controlBlock)) {\n    controlBlock = parseControlBlock(ecc, controlBlock);\n  }\n  const { leafVersion } = controlBlock;\n\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    Buffer.concat([Buffer.of(leafVersion), serializeScriptSize(tapscript), tapscript])\n  );\n}\n\n/**\n * Calculates the taptree root hash from a control block and script.\n * @param ecc Elliptic curve implementation\n * @param controlBlock the control block, either raw or parsed\n * @param tapscript the leaf script corresdponding to the control block\n * @param tapleafHash the leaf hash if already calculated\n * @returns {Buffer} the taptree root hash\n */\nexport function getTaptreeRoot(\n  ecc: TinySecp256k1Interface,\n  controlBlock: Buffer | ControlBlock,\n  tapscript: Buffer,\n  tapleafHash?: Buffer\n): Buffer {\n  if (Buffer.isBuffer(controlBlock)) {\n    controlBlock = parseControlBlock(ecc, controlBlock);\n  }\n  const { path } = controlBlock;\n\n  tapleafHash = tapleafHash || getTapleafHash(ecc, controlBlock, tapscript);\n\n  // `taptreeMerkleHash` begins as our tapscript tapleaf hash and its value iterates\n  // through its parent tapbranch hashes until it ends up as the taptree root hash\n  let taptreeMerkleHash = tapleafHash;\n  for (const taptreeSiblingHash of path) {\n    taptreeMerkleHash =\n      Buffer.compare(taptreeMerkleHash, taptreeSiblingHash) === -1\n        ? bcrypto.taggedHash('TapBranch', Buffer.concat([taptreeMerkleHash, taptreeSiblingHash]))\n        : bcrypto.taggedHash('TapBranch', Buffer.concat([taptreeSiblingHash, taptreeMerkleHash]));\n  }\n\n  return taptreeMerkleHash;\n}\n\nexport function getTweakedOutputKey(payment: bpayments.Payment): Buffer {\n  assert(payment.output);\n  if (payment.output.length === 34) {\n    return payment.output?.subarray(2);\n  }\n  throw new Error(`invalid p2tr tweaked output key size ${payment.output.length}`);\n}\n\n/**\n * @returns output script for either script path input controlBlock\n * & leafScript OR key path input internalPubKey & taptreeRoot\n */\nexport function createTaprootOutputScript(\n  p2trArgs: { internalPubKey: Buffer; taptreeRoot: Buffer } | { controlBlock: Buffer; leafScript: Buffer }\n): Buffer {\n  let internalPubKey: Buffer | undefined;\n  let taptreeRoot: Buffer | undefined;\n  if ('internalPubKey' in p2trArgs) {\n    internalPubKey = p2trArgs.internalPubKey;\n    taptreeRoot = p2trArgs.taptreeRoot;\n  } else {\n    internalPubKey = parseControlBlock(eccLib, p2trArgs.controlBlock).internalPubkey;\n    taptreeRoot = getTaptreeRoot(eccLib, p2trArgs.controlBlock, p2trArgs.leafScript);\n  }\n  const outputKey = tapTweakPubkey(eccLib, internalPubKey, taptreeRoot).xOnlyPubkey;\n  return bscript.compile([bscript.OPS.OP_1, Buffer.from(outputKey)]);\n}\n\n/**\n * @returns x-only taproot output key (tapOutputKey)\n */\nexport function getTaprootOutputKey(outputScript: Buffer | (number | Buffer)[]): Buffer {\n  const outputDecompiled = bscript.decompile(outputScript);\n  if (outputDecompiled?.length !== 2) {\n    throw new Error('invalid taproot output script');\n  }\n  const [op1, outputKey] = outputDecompiled;\n  if (op1 !== bscript.OPS.OP_1 || !Buffer.isBuffer(outputKey) || outputKey.length !== 32) {\n    throw new Error('invalid taproot output script');\n  }\n  return outputKey;\n}\n"]}
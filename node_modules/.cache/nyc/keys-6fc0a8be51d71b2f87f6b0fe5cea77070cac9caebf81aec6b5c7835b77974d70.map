{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/testutil/keys.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/testutil/keys.ts"],"names":[],"mappings":";;AAaA,wBAEC;AAED,oCAEC;AAaD,4DAEC;AAED,gCAEC;AAED,gDAaC;AAED,oDAEC;AAzDD,iCAA+D;AAC/D,iCAAiC;AAGjC,2DAA4D;AAC5D,4CAA4D;AAC5D,0CAAuC;AAEvC,MAAM,KAAK,GAAa,IAAA,oBAAY,EAAC,eAAG,CAAC,CAAC;AAK1C,SAAgB,MAAM,CAAC,IAAY;IACjC,OAAO,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC,CAAC;AAC3E,CAAC;AAED,SAAgB,YAAY,CAAC,IAAY;IACvC,OAAO,CAAC,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,EAAE,MAAM,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC;AACzE,CAAC;AAED,SAAS,kBAAkB,CAAC,KAAK;IAC/B,2CAA2C;IAC3C,OAAO,kBAAM,CAAC,UAAU,CAAC;QACvB,UAAU,EAAE,KAAK;QACjB,OAAO,EAAE,mBAAQ,CAAC,OAAO;QACzB,GAAG,EAAE,GAAW,EAAE;YAChB,OAAO,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,KAAK,CAAC,CAAC;QACjC,CAAC;KACF,CAAC,CAAC;AACL,CAAC;AAED,SAAgB,wBAAwB,CAAC,MAAsB;IAC7D,OAAO,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,kBAAkB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AACvG,CAAC;AAED,SAAgB,UAAU,CAAC,MAA8B,EAAE,CAAiB;IAC1E,OAAO,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC;AACxD,CAAC;AAED,SAAgB,kBAAkB,CAAI,MAAiB,EAAE,MAAS;IAChE,MAAM,EAAE,GAAG,CAAC,CAAI,EAAE,CAAI,EAAE,EAAE,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IAChG,MAAM,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,GAAG,MAAM,CAAC;IACrC,IAAI,EAAE,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,CAAC;QACrB,OAAO,KAAK,CAAC;IACf,CAAC;IACD,IAAI,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;QACvB,OAAO,KAAK,CAAC;IACf,CAAC;IACD,IAAI,EAAE,CAAC,MAAM,EAAE,KAAK,CAAC,EAAE,CAAC;QACtB,OAAO,IAAI,CAAC;IACd,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AAC3C,CAAC;AAED,SAAgB,oBAAoB;IAClC,OAAO,IAAI,2BAAc,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC,CAAC;AACrD,CAAC","sourcesContent":["import { BIP32API, BIP32Factory, BIP32Interface } from 'bip32';\nimport * as crypto from 'crypto';\n\nimport { Triple } from '../bitgo/types';\nimport { RootWalletKeys } from '../bitgo/wallet/WalletKeys';\nimport { ecc, ECPair, ECPairInterface } from '../noble_ecc';\nimport { networks } from '../networks';\n\nconst bip32: BIP32API = BIP32Factory(ecc);\n\nexport type KeyTriple = Triple<BIP32Interface>;\nexport type UncompressedKeyTriple = Triple<ECPairInterface>;\n\nexport function getKey(seed: string): BIP32Interface {\n  return bip32.fromSeed(crypto.createHash('sha256').update(seed).digest());\n}\n\nexport function getKeyTriple(seed: string): KeyTriple {\n  return [getKey(seed + '.0'), getKey(seed + '.1'), getKey(seed + '.2')];\n}\n\nfunction getUncompressedKey(input) {\n  // Using input for deterministic randomness\n  return ECPair.makeRandom({\n    compressed: false,\n    network: networks.testnet,\n    rng: (): Buffer => {\n      return Buffer.alloc(32, input);\n    },\n  });\n}\n\nexport function getUncompressedKeyTriple(inputs: Triple<number>): UncompressedKeyTriple {\n  return [getUncompressedKey(inputs[0]), getUncompressedKey(inputs[1]), getUncompressedKey(inputs[2])];\n}\n\nexport function getKeyName(triple: Triple<BIP32Interface>, k: BIP32Interface): string | undefined {\n  return ['user', 'backup', 'bitgo'][triple.indexOf(k)];\n}\n\nexport function getDefaultCosigner<T>(keyset: Triple<T>, signer: T): T {\n  const eq = (a: T, b: T) => a === b || (Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.equals(b));\n  const [user, backup, bitgo] = keyset;\n  if (eq(signer, user)) {\n    return bitgo;\n  }\n  if (eq(signer, backup)) {\n    return bitgo;\n  }\n  if (eq(signer, bitgo)) {\n    return user;\n  }\n  throw new Error(`signer not in pubkeys`);\n}\n\nexport function getDefaultWalletKeys(): RootWalletKeys {\n  return new RootWalletKeys(getKeyTriple('default'));\n}\n"]}
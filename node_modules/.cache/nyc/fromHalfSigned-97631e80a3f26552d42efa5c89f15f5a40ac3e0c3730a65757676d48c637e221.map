{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/psbt/fromHalfSigned.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/psbt/fromHalfSigned.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\nimport { PsbtInputUpdate, PartialSig } from 'bip174/src/lib/interfaces';\nimport { ecc as eccLib, TxOutput, taproot, getMainnet, networks } from '../..';\nimport { UtxoTransaction } from '../UtxoTransaction';\nimport { parseSignatureScript } from '../parseInput';\nimport { getSignaturesWithPublicKeys } from '../signature';\nimport { hasWitnessData } from '../outputScripts';\n\nfunction omitUndefined<T extends Record<string, unknown>>(v: Record<string, unknown>): T {\n  return Object.fromEntries(Object.entries(v).filter(([k, v]) => v !== undefined)) as T;\n}\n\nexport function getInputUpdate(\n  tx: UtxoTransaction<bigint>,\n  vin: number,\n  prevOuts: (TxOutput<bigint> & { prevTx?: Buffer })[]\n): PsbtInputUpdate {\n  const nonWitnessUtxo = prevOuts[vin].prevTx;\n  const { script, witness } = tx.ins[vin];\n  if (script.length === 0 && witness.length === 0) {\n    return nonWitnessUtxo ? { nonWitnessUtxo } : {};\n  }\n\n  const parsedInput = parseSignatureScript(tx.ins[vin]);\n  assert.ok(parsedInput.scriptType !== 'taprootKeyPathSpend');\n\n  function getPartialSigs(): PartialSig[] {\n    assert.ok(parsedInput.scriptType !== 'taprootKeyPathSpend');\n    return getSignaturesWithPublicKeys(tx, vin, prevOuts, parsedInput.publicKeys).flatMap((signature, i) =>\n      signature\n        ? [\n            {\n              pubkey: parsedInput.publicKeys[i],\n              signature,\n            },\n          ]\n        : []\n    );\n  }\n  // Because Zcash directly hashes the value for non-segwit transactions, we do not need to check indirectly\n  // with the previous transaction. Therefore, we can treat Zcash non-segwit transactions as Bitcoin\n  // segwit transactions\n  if (\n    parsedInput.scriptType !== 'taprootScriptPathSpend' &&\n    !hasWitnessData(parsedInput.scriptType) &&\n    !nonWitnessUtxo &&\n    getMainnet(tx.network) !== networks.zcash\n  ) {\n    throw new Error(`scriptType ${parsedInput.scriptType} requires prevTx Buffer`);\n  }\n\n  switch (parsedInput.scriptType) {\n    case 'p2shP2pk':\n      return {\n        nonWitnessUtxo,\n        partialSig: [{ pubkey: parsedInput.publicKeys[0], signature: parsedInput.signatures[0] }],\n      };\n    case 'p2sh':\n    case 'p2wsh':\n    case 'p2shP2wsh':\n      return omitUndefined({\n        nonWitnessUtxo,\n        partialSig: getPartialSigs(),\n        redeemScript: parsedInput.redeemScript,\n        witnessScript: parsedInput.witnessScript,\n      });\n    case 'taprootScriptPathSpend':\n      const leafHash = taproot.getTapleafHash(eccLib, parsedInput.controlBlock, parsedInput.pubScript);\n      return {\n        tapLeafScript: [\n          {\n            controlBlock: parsedInput.controlBlock,\n            script: parsedInput.pubScript,\n            leafVersion: parsedInput.leafVersion,\n          },\n        ],\n        tapScriptSig: getPartialSigs().map((obj) => ({ ...obj, leafHash })),\n      };\n  }\n}\n\n/**\n * Takes a partially signed transaction and removes the scripts and signatures.\n *\n * Inputs must be one of:\n *  - p2shP2pk\n *  - p2sh 2-of-3\n *  - p2shP2wsh 2-of-3\n *  - p2wsh 2-of-3\n *  - p2tr script path 2-of-2\n *\n * @param tx the partially signed transaction\n * @param prevOuts\n *\n * @return the removed scripts and signatures, ready to be added to a PSBT\n */\nexport function unsign(tx: UtxoTransaction<bigint>, prevOuts: TxOutput<bigint>[]): PsbtInputUpdate[] {\n  return tx.ins.map((input, vin) => {\n    const update = getInputUpdate(tx, vin, prevOuts);\n    input.witness = [];\n    input.script = Buffer.alloc(0);\n    return update;\n  });\n}\n"]}
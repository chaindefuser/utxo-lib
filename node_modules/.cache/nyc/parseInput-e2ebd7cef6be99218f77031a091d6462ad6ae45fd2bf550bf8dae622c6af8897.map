{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/parseInput.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/parseInput.ts"],"names":[],"mappings":";;AAOA,wDAKC;AAKD,gDAGC;AAKD,4DAWC;AAKD,wCAKC;AAgaD,oDAuBC;AAED,4DAuBC;AAuHD,gDAwBC;AA4BD,wCAkBC;AAED,4DAeC;AA5sBD,4BAA4B;AAC5B,uCAAuC;AACvC,iDAA2D;AAE3D,mCAAmC;AACnC,mDAAmD;AAEnD,SAAgB,sBAAsB,CAAC,CAAkB;IACvD,IAAI,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;QACvB,OAAO,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC;IACxB,CAAC;IACD,OAAO,CAAC,KAAK,CAAC,CAAC;AACjB,CAAC;AAED;;GAEG;AACH,SAAgB,kBAAkB,CAAC,YAAoB;IACrD,sFAAsF;IACtF,OAAO,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,EAAE,IAAI,YAAY,CAAC,MAAM,IAAI,YAAY,CAAC,MAAM,GAAG,EAAE,KAAK,CAAC,CAAC;AACtG,CAAC;AAED;;GAEG;AACH,SAAgB,wBAAwB,CAAC,YAAoB;IAC3D,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,EAAE,CAAC;QACnC,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;IACjD,CAAC;IACD,IAAI,YAAY,CAAC,MAAM,KAAK,EAAE,EAAE,CAAC;QAC/B,OAAO,CAAC,CAAC;IACX,CAAC;IACD,IAAI,YAAY,CAAC,MAAM,KAAK,EAAE,EAAE,CAAC;QAC/B,OAAO,CAAC,CAAC;IACX,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,kCAAkC,CAAC,CAAC;AACtD,CAAC;AAED;;GAEG;AACH,SAAgB,cAAc,CAAC,YAAoB;IACjD,IAAI,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC7D,OAAO,YAAY,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;IAChC,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;AAC7C,CAAC;AAkID,SAAS,gBAAgB;IACvB,OAAO;QACL,SAAS,EAAE,EAAE;QACb,eAAe,EAAE,EAAE;QACnB,gBAAgB,EAAE,EAAE;QACpB,YAAY,EAAE,EAAE;QAChB,SAAS,EAAE,EAAE;KACd,CAAC;AACJ,CAAC;AAED,MAAM,UAAW,SAAQ,KAAK;IAG5B,YAAY,OAAe;QACzB,KAAK,CAAC,OAAO,CAAC,CAAC;QAHjB,uGAAuG;QACvG,WAAM,GAAG,YAAY,CAAC;IAGtB,CAAC;IAED,MAAM,CAAC,iBAAiB,CAAC,CAAuB;QAC9C,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,SAAS,IAAI,CAAC,EAAE,CAAC;YAC5C,OAAO,IAAI,UAAU,CAAC,8BAA8B,CAAC,CAAC;QACxD,CAAC;QACD,OAAO,IAAI,UAAU,CAAC,kBAAkB,CAAC,EAAE,CAAC,CAAC;IAC/C,CAAC;CACF;AAED;;;;GAIG;AACH,SAAS,WAAW,CAAC,MAAwB,EAAE,OAA+B;IAC5E;;OAEG;IACH,SAAS,YAAY,CAAC,CAAkB,EAAE,CAAuB;QAC/D,QAAQ,CAAC,EAAE,CAAC;YACV,KAAK,MAAM;gBACT,OAAO,CAAC,KAAK,OAAO,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC;YACtE,KAAK,MAAM,CAAC;YACZ,KAAK,MAAM,CAAC;YACZ,KAAK,MAAM,CAAC;YACZ,KAAK,kBAAkB,CAAC;YACxB,KAAK,aAAa,CAAC;YACnB,KAAK,mBAAmB;gBACtB,OAAO,CAAC,KAAK,OAAO,CAAC,CAAC,CAAC,CAAC;YAC1B,KAAK,SAAS;gBACZ,OAAO,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,MAAM,KAAK,EAAE,IAAI,CAAC,CAAC,MAAM,KAAK,EAAE,CAAC,CAAC;YACpE,KAAK,eAAe;gBAClB,OAAO,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,KAAK,EAAE,CAAC;YAC/C,KAAK,YAAY;gBACf,OAAO,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,sBAAsB,CAAC,CAAC,CAAC,CAAC;YACzD,KAAK,gBAAgB;gBACnB,OAAO,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,kBAAkB,CAAC,CAAC,CAAC,CAAC;YACrD;gBACE,MAAM,IAAI,KAAK,CAAC,2BAA2B,CAAC,EAAE,CAAC,CAAC;QACpD,CAAC;IACH,CAAC;IAED,IAAI,MAAM,CAAC,MAAM,KAAK,OAAO,CAAC,MAAM,EAAE,CAAC;QACrC,OAAO,IAAI,UAAU,CAAC,iBAAiB,CAAC,CAAC;IAC3C,CAAC;IAED,gCAAgC;IAChC,yCAAyC;IACzC,OAAO,OAAO,CAAC,MAAM,CAAC,CAAC,GAA6B,EAAE,CAAC,EAAE,CAAC,EAA4B,EAAE;QACtF,+CAA+C;QAC/C,IAAI,GAAG,YAAY,UAAU,EAAE,CAAC;YAC9B,OAAO,GAAG,CAAC;QACb,CAAC;QAED,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QAEpB,uEAAuE;QACvE,IAAI,OAAO,CAAC,KAAK,QAAQ,IAAI,SAAS,IAAI,CAAC,EAAE,CAAC;YAC5C,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;gBACxB,OAAO,IAAI,UAAU,CAAC,6BAA6B,CAAC,CAAC;YACvD,CAAC;YACD,MAAM,GAAG,GAAG,sBAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACjC,IAAI,CAAC,GAAG,EAAE,CAAC;gBACT,OAAO,IAAI,UAAU,CAAC,iCAAiC,CAAC,CAAC;YAC3D,CAAC;YACD,MAAM,KAAK,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC;YAC7C,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;gBAChC,OAAO,KAAK,CAAC;YACf,CAAC;YACD,GAAG,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC;gBAClB,MAAM,EAAE,CAAC;gBACT,KAAK;aACN,CAAC,CAAC;YACH,OAAO,GAAG,CAAC;QACb,CAAC;QAED,MAAM,KAAK,GAAG,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACjC,IAAI,CAAC,KAAK,EAAE,CAAC;YACX,OAAO,UAAU,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC;QACzC,CAAC;QAED,4DAA4D;QAC5D,IAAI,CAAC,KAAK,YAAY,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC;YAClC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACjB,CAAC;aAAM,IAAI,CAAC,IAAI,GAAG,EAAE,CAAC;YACpB,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;gBACxB,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;YAC3C,CAAC;YACD,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;QACjB,CAAC;QAED,OAAO,GAAG,CAAC;IACb,CAAC,EAAE,gBAAgB,EAAE,CAAC,CAAC;AACzB,CAAC;AAED;;;;GAIG;AACH,SAAS,eAAe,CAAC,MAAwB,EAAE,QAAkC;IACnF,KAAK,MAAM,CAAC,IAAI,QAAQ,EAAE,CAAC;QACzB,MAAM,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;QACjC,IAAI,CAAC,YAAY,UAAU,EAAE,CAAC;YAC5B,SAAS;QACX,CAAC;QACD,OAAO,CAAC,CAAC;IACX,CAAC;IACD,OAAO,IAAI,UAAU,CAAC,qBAAqB,CAAC,CAAC;AAC/C,CAAC;AAwBD,SAAS,QAAQ,CAAC,CAAsB;IACtC,OAAO,OAAO,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC;AACzC,CAAC;AAED,SAAS,eAAe,CAAC,CAAsB;IAC7C,OAAO,OAAO,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC;AACxC,CAAC;AAED,SAAS,cAAc,CAAC,CAAsB;IAC5C,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,OAAO,CAAC,CAAC;AACzC,CAAC;AAED,MAAM,aAAa,GAA+C,CAAC,CAAC,EAAE,EAAE;IACtE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;QACjB,OAAO,IAAI,UAAU,CAAC,uBAAuB,CAAC,CAAC;IACjD,CAAC;IACD,MAAM,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,YAAY,EAAE,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,aAAa,CAAC,EAAE,CAAC,CAAC,CAAC;IAC/F,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IACD,OAAO;QACL,UAAU,EAAE,UAAU;QACtB,UAAU,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,SAAS,CAAa;QAC5D,UAAU,EAAE,KAAK,CAAC,YAAY,CAAa;KAC5C,CAAC;AACJ,CAAC,CAAC;AAEF,SAAS,SAAS,CAChB,SAA2B,EAC3B,UAA0C;IAE1C,MAAM,WAAW,GAA2B,CAAC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE,kBAAkB,CAAC,CAAC;IAElH,MAAM,KAAK,GAAG,eAAe,CAAC,SAAS,EAAE;QACvC,2CAA2C;QAC3C,CAAC,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,EAAE,SAAS,EAAE,WAAW,EAAE,CAAC;QAChE,yCAAyC;QACzC,CAAC,MAAM,EAAE,YAAY,EAAE,YAAY,EAAE,YAAY,EAAE,EAAE,SAAS,EAAE,WAAW,EAAE,CAAC;KAC/E,CAAC,CAAC;IACH,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,CAAC,YAAY,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;IAExC,IAAI,CAAC,IAAA,gBAAQ,EAAC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;IAC1C,CAAC;IAED,OAAO;QACL,UAAU;QACV,UAAU,EAAE,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC;QACzC,SAAS,EAAE,YAAY,CAAC,MAAM;QAC9B,UAAU,EAAE,KAAK,CAAC,YAAY,CAA4C;QAC1E,YAAY,EAAE,UAAU,KAAK,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;QACrE,aAAa,EAAE,UAAU,KAAK,WAAW,IAAI,UAAU,KAAK,OAAO,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;KACtG,CAAC;AACJ,CAAC;AAED,MAAM,aAAa,GAA2C,CAAC,CAAC,EAAE,EAAE;IAClE,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC;QACjB,OAAO,IAAI,UAAU,CAAC,uBAAuB,CAAC,CAAC;IACjD,CAAC;IACD,OAAO,SAAS,CAAC,CAAC,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AACrC,CAAC,CAAC;AAEF,MAAM,kBAAkB,GAA2C,CAAC,CAAC,EAAE,EAAE;IACvE,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC,EAAE,CAAC;QACxB,OAAO,IAAI,UAAU,CAAC,+BAA+B,CAAC,CAAC;IACzD,CAAC;IACD,OAAO,EAAE,GAAG,SAAS,CAAC,CAAC,CAAC,OAAO,EAAE,WAAW,CAAC,EAAE,YAAY,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAW,EAAE,CAAC;AACvF,CAAC,CAAC;AAEF,MAAM,cAAc,GAA2C,CAAC,CAAC,EAAE,EAAE;IACnE,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC;QACvB,OAAO,IAAI,UAAU,CAAC,wBAAwB,CAAC,CAAC;IAClD,CAAC;IACD,OAAO,SAAS,CAAC,CAAC,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;AACvC,CAAC,CAAC;AAEF,MAAM,uBAAuB,GAAqD,CAAC,CAAC,EAAE,EAAE;IACtF,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC;QACvB,OAAO,IAAI,UAAU,CAAC,wBAAwB,CAAC,CAAC;IAClD,CAAC;IACD,MAAM,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC,OAAO,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC;IACrD,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IACD,MAAM,UAAU,GAAG,KAAK,CAAC,YAAY,CAAa,CAAC;IACnD,IAAI,sBAAsB,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;QAC1C,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;IACxD,CAAC;IACD,OAAO;QACL,UAAU,EAAE,qBAAqB;QACjC,UAAU;KACX,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,0BAA0B,GAA8C,CAAC,CAAC,EAAE,EAAE;IAClF,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,EAAE,CAAC;QACvB,OAAO,IAAI,UAAU,CAAC,wBAAwB,CAAC,CAAC;IAClD,CAAC;IACD,mBAAmB;IACnB,MAAM,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC,OAAO,EAAE;QACnC,YAAY;QACZ,YAAY;QACZ,EAAE,SAAS,EAAE,CAAC,eAAe,EAAE,mBAAmB,EAAE,eAAe,EAAE,aAAa,CAAC,EAAE;QACrF,gBAAgB;KACjB,CAAC,CAAC;IACH,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IACD,MAAM,CAAC,YAAY,CAAC,GAAG,KAAK,CAAC,gBAAgB,CAAC,CAAC;IAC/C,MAAM,eAAe,GAAG,wBAAwB,CAAC,YAAY,CAAC,CAAC;IAE/D,MAAM,WAAW,GAAG,cAAc,CAAC,YAAY,CAAC,CAAC;IAEjD,OAAO;QACL,UAAU,EAAE,wBAAwB;QACpC,SAAS,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM;QACrC,UAAU,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,eAAe,CAAqB;QAC1E,UAAU,EAAE,KAAK,CAAC,YAAY,CAAqB;QACnD,YAAY;QACZ,eAAe;QACf,WAAW;KACZ,CAAC;AACJ,CAAC,CAAC;AAEF;;;;;;;;GAQG;AACH,SAAgB,oBAAoB,CAClC,KAAc;IAEd,MAAM,SAAS,GAAG,sBAAO,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAClD,MAAM,OAAO,GAAG;QACd,aAAa;QACb,kBAAkB;QAClB,cAAc;QACd,uBAAuB;QACvB,0BAA0B;QAC1B,aAAa;KACL,CAAC;IACX,KAAK,MAAM,CAAC,IAAI,OAAO,EAAE,CAAC;QACxB,MAAM,MAAM,GAAG,CAAC,CAAC;YACf,MAAM,EAAE,SAAS,EAAE,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,SAAS;YAClD,OAAO,EAAE,KAAK,CAAC,OAAO,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO;SAC3D,CAAC,CAAC;QACH,IAAI,MAAM,YAAY,UAAU,EAAE,CAAC;YACjC,SAAS;QACX,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AAC3C,CAAC;AAED,SAAgB,wBAAwB,CAAC,KAAc;IACrD,MAAM,MAAM,GAAG,oBAAoB,CAAC,KAAK,CAAC,CAAC;IAE3C,IACE,CAAC,IAAA,gCAAgB,EAAC,MAAM,CAAC,UAAU,CAAC;QACpC,MAAM,CAAC,UAAU,KAAK,qBAAqB;QAC3C,MAAM,CAAC,UAAU,KAAK,wBAAwB,EAC9C,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACzC,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,UAAU,EAAE,CAAC;QACvB,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;IACxC,CAAC;IACD,IACE,MAAM,CAAC,UAAU,KAAK,qBAAqB;QAC3C,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC;QAC9B,CAAC,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,IAAI,MAAM,CAAC,UAAU,KAAK,wBAAwB,CAAC,EAClF,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC7C,CAAC;IAED,OAAO,MAAkE,CAAC;AAC5E,CAAC;AAED,MAAM,sBAAsB,GAA6C,CAAC,SAAS,EAAE,UAAU,EAAE,EAAE;IACjG,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;QAC9B,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACzC,CAAC;IACD,MAAM,KAAK,GAAG,WAAW,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,SAAS,EAAE,CAAC,SAAS,EAAE,aAAa,CAAC,EAAE,CAAC,CAAC,CAAC;IACpF,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IACD,MAAM,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;IAClC,OAAO;QACL,UAAU;QACV,UAAU,EAAE,MAAM,CAAC,KAAK,CAAC,SAAS,CAAa;QAC/C,SAAS,EAAE,SAAS;QACpB,YAAY,EAAE,SAAS;KACxB,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,kBAAkB,GAAyC,CAAC,SAAS,EAAE,UAAU,EAAE,EAAE;IACzF,IAAI,UAAU,KAAK,wBAAwB,IAAI,UAAU,KAAK,qBAAqB,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;QACjH,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACzC,CAAC;IACD,MAAM,KAAK,GAAG,WAAW,CACvB,CAAC,SAAS,CAAC,EACX,CAAC,EAAE,SAAS,EAAE,CAAC,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,MAAM,EAAE,kBAAkB,CAAC,EAAE,CAAC,CACvF,CAAC;IACF,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,CAAC,YAAY,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;IAExC,IAAI,CAAC,IAAA,gBAAQ,EAAC,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC;QAC7C,MAAM,IAAI,KAAK,CAAC,sBAAsB,CAAC,CAAC;IAC1C,CAAC;IAED,OAAO;QACL,UAAU;QACV,UAAU,EAAE,YAAY,CAAC,KAAK,CAAC,SAAS,CAAC;QACzC,SAAS,EAAE,YAAY,CAAC,MAAM;QAC9B,YAAY,EAAE,UAAU,KAAK,MAAM,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;QACrE,aAAa,EAAE,UAAU,KAAK,WAAW,IAAI,UAAU,KAAK,OAAO,CAAC,CAAC,CAAC,YAAY,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS;KACtG,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,4BAA4B,GAAmD,CAAC,SAAS,EAAE,UAAU,EAAE,EAAE;IAC7G,IACE,UAAU,KAAK,MAAM;QACrB,UAAU,KAAK,OAAO;QACtB,UAAU,KAAK,WAAW;QAC1B,UAAU,KAAK,wBAAwB;QACvC,UAAU,KAAK,UAAU,EACzB,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACzC,CAAC;IACD,MAAM,KAAK,GAAG,WAAW,CAAC,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,SAAS,EAAE,CAAC,MAAM,EAAE,eAAe,CAAC,EAAE,CAAC,CAAC,CAAC;IACnF,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,MAAM,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC,SAAS,CAAC,CAAC;IAElC,OAAO;QACL,UAAU,EAAE,qBAAqB;QACjC,UAAU,EAAE,MAAM,CAAC,KAAK,CAAC,eAAe,CAAa;QACrD,SAAS,EAAE,SAAS;KACrB,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,+BAA+B,GAAsD,CAAC,SAAS,EAAE,UAAU,EAAE,EAAE;IACnH,IACE,UAAU,KAAK,MAAM;QACrB,UAAU,KAAK,OAAO;QACtB,UAAU,KAAK,WAAW;QAC1B,UAAU,KAAK,qBAAqB;QACpC,UAAU,KAAK,UAAU,EACzB,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,qBAAqB,CAAC,CAAC;IACzC,CAAC;IACD,MAAM,KAAK,GAAG,WAAW,CACvB,CAAC,SAAS,CAAC,EACX,CAAC,EAAE,SAAS,EAAE,CAAC,eAAe,EAAE,mBAAmB,EAAE,eAAe,EAAE,aAAa,CAAC,EAAE,CAAC,CACxF,CAAC;IACF,IAAI,KAAK,YAAY,UAAU,EAAE,CAAC;QAChC,OAAO,KAAK,CAAC;IACf,CAAC;IAED,OAAO;QACL,UAAU;QACV,SAAS,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,MAAM;QACrC,UAAU,EAAE,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,eAAe,CAAqB;KAC3E,CAAC;AACJ,CAAC,CAAC;AA0BF,SAAgB,kBAAkB,CAChC,cAA8B,EAC9B,UAAgC;IAEhC,MAAM,MAAM,GACV,UAAU,KAAK,qBAAqB;QAClC,CAAC,CAAC,4BAA4B,CAAC,cAAc,EAAE,UAAU,CAAC;QAC1D,CAAC,CAAC,UAAU,KAAK,wBAAwB;YACzC,CAAC,CAAC,+BAA+B,CAAC,cAAc,EAAE,UAAU,CAAC;YAC7D,CAAC,CAAC,kBAAkB,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;IAErD,IAAI,MAAM,YAAY,UAAU,EAAE,CAAC;QACjC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAClC,CAAC;IAED,IACE,CAAC,MAAM,CAAC,UAAU,KAAK,qBAAqB,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC;QAC/E,CAAC,MAAM,CAAC,UAAU,KAAK,wBAAwB,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC;QAClF,CAAC,IAAA,gCAAgB,EAAC,MAAM,CAAC,UAAU,CAAC,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,CAAC,EACvE,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC7C,CAAC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AA4BD,SAAgB,cAAc,CAC5B,cAA8B,EAC9B,UAA4B;IAE5B,MAAM,MAAM,GACV,UAAU,KAAK,UAAU;QACvB,CAAC,CAAC,sBAAsB,CAAC,cAAc,EAAE,UAAU,CAAC;QACpD,CAAC,CAAC,kBAAkB,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC;IAErD,IAAI,MAAM,YAAY,UAAU,EAAE,CAAC;QACjC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAClC,CAAC;IAED,IAAI,MAAM,CAAC,UAAU,KAAK,UAAU,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACvE,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC7C,CAAC;IAED,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAgB,wBAAwB,CAAC,IAAY;IACnD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;IAC9B,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC;QACtB,MAAM,IAAI,KAAK,CAAC,iBAAiB,IAAI,GAAG,CAAC,CAAC;IAC5C,CAAC;IACD,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC9C,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;IAC9C,IAAI,KAAK,CAAC,KAAK,CAAC,IAAI,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;QACjC,MAAM,IAAI,KAAK,CAAC,0DAA0D,IAAI,EAAE,CAAC,CAAC;IACpF,CAAC;IACD,IAAI,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,CAAC,EAAE,CAAC;QAC3B,MAAM,IAAI,KAAK,CAAC,sCAAsC,CAAC,CAAC;IAC1D,CAAC;IAED,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC;AAC1B,CAAC","sourcesContent":["/* eslint no-redeclare: 0 */\nimport * as opcodes from 'bitcoin-ops';\nimport { TxInput, script as bscript } from 'bitcoinjs-lib';\n\nimport { isTriple } from './types';\nimport { isScriptType2Of3 } from './outputScripts';\n\nexport function isPlaceholderSignature(v: number | Buffer): boolean {\n  if (Buffer.isBuffer(v)) {\n    return v.length === 0;\n  }\n  return v === 0;\n}\n\n/**\n * @return true iff P2TR script path's control block matches BitGo's need\n */\nexport function isValidControlBock(controlBlock: Buffer): boolean {\n  // The last stack element is called the control block c, and must have length 33 + 32m\n  return Buffer.isBuffer(controlBlock) && 33 <= controlBlock.length && controlBlock.length % 32 === 1;\n}\n\n/**\n * @return script path level for P2TR control block\n */\nexport function calculateScriptPathLevel(controlBlock: Buffer): number {\n  if (!Buffer.isBuffer(controlBlock)) {\n    throw new Error('Invalid control block type.');\n  }\n  if (controlBlock.length === 65) {\n    return 1;\n  }\n  if (controlBlock.length === 97) {\n    return 2;\n  }\n  throw new Error('unexpected control block length.');\n}\n\n/**\n * @return leaf version for P2TR control block.\n */\nexport function getLeafVersion(controlBlock: Buffer): number {\n  if (Buffer.isBuffer(controlBlock) && controlBlock.length > 0) {\n    return controlBlock[0] & 0xfe;\n  }\n  throw new Error('unexpected leafVersion.');\n}\n\nexport type ParsedScriptType2Of3 =\n  | 'p2sh'\n  | 'p2shP2wsh'\n  | 'p2wsh'\n  | 'taprootKeyPathSpend' // only implemented for p2trMusig2\n  | 'taprootScriptPathSpend'; // can be for either p2tr or p2trMusig2 output script\n\nexport type ParsedScriptType = ParsedScriptType2Of3 | 'p2shP2pk';\n\nexport type ParsedPubScript = {\n  scriptType: ParsedScriptType;\n};\n\nexport type ParsedSignatureScript = {\n  scriptType: ParsedScriptType;\n};\n\nexport interface ParsedSignatureScriptP2shP2pk extends ParsedSignatureScript {\n  scriptType: 'p2shP2pk';\n  publicKeys: [Buffer];\n  signatures: [Buffer];\n}\n\nexport interface ParsedPubScriptTaprootKeyPath extends ParsedPubScript {\n  scriptType: 'taprootKeyPathSpend';\n  // x-only tapOutputKey\n  publicKeys: [Buffer];\n  pubScript: Buffer;\n}\n\nexport interface ParsedPubScriptTaprootScriptPath extends ParsedPubScript {\n  scriptType: 'taprootScriptPathSpend';\n  publicKeys: [Buffer, Buffer];\n  pubScript: Buffer;\n}\n\nexport type ParsedPubScriptTaproot = ParsedPubScriptTaprootKeyPath | ParsedPubScriptTaprootScriptPath;\n\nexport interface ParsedPubScriptP2ms extends ParsedPubScript {\n  scriptType: 'p2sh' | 'p2shP2wsh' | 'p2wsh';\n  publicKeys: [Buffer, Buffer, Buffer];\n  pubScript: Buffer;\n  redeemScript: Buffer | undefined;\n  witnessScript: Buffer | undefined;\n}\n\nexport interface ParsedPubScriptP2shP2pk extends ParsedPubScript {\n  scriptType: 'p2shP2pk';\n  publicKeys: [Buffer];\n  pubScript: Buffer;\n  redeemScript: Buffer;\n}\n\nexport interface ParsedSignatureScriptP2ms extends ParsedSignatureScript {\n  scriptType: 'p2sh' | 'p2shP2wsh' | 'p2wsh';\n  publicKeys: [Buffer, Buffer, Buffer];\n  signatures:\n    | [Buffer, Buffer] // fully-signed transactions with signatures\n    /* Partially signed transactions with placeholder signatures.\n       For p2sh, the placeholder is OP_0 (number 0) */\n    | [Buffer | 0, Buffer | 0, Buffer | 0];\n  pubScript: Buffer;\n  redeemScript: Buffer | undefined;\n  witnessScript: Buffer | undefined;\n}\n\n/**\n * Keypath spends only have a single signature\n */\nexport interface ParsedSignatureScriptTaprootKeyPath extends ParsedSignatureScript {\n  scriptType: 'taprootKeyPathSpend';\n  signatures: [Buffer];\n}\n\n/**\n * Taproot Scriptpath spends are more similar to regular p2ms spends and have two public keys and\n * two signatures\n */\nexport interface ParsedSignatureScriptTaprootScriptPath extends ParsedSignatureScript {\n  scriptType: 'taprootScriptPathSpend';\n  publicKeys: [Buffer, Buffer];\n  signatures: [Buffer, Buffer];\n  controlBlock: Buffer;\n  leafVersion: number;\n  /** Indicates the level inside the taptree. */\n  scriptPathLevel: number;\n  pubScript: Buffer;\n}\n\nexport type ParsedSignatureScriptTaproot = ParsedSignatureScriptTaprootKeyPath | ParsedSignatureScriptTaprootScriptPath;\n\ntype DecompiledScript = Array<Buffer | number>;\n\n/**\n * Static script elements\n */\ntype ScriptPatternConstant =\n  | 'OP_0'\n  | 'OP_1'\n  | 'OP_2'\n  | 'OP_3'\n  | 'OP_CHECKMULTISIG'\n  | 'OP_CHECKSIG'\n  | 'OP_CHECKSIGVERIFY';\n\n/**\n * Script elements that can be captured\n */\ntype ScriptPatternCapture =\n  | ':pubkey'\n  | ':pubkey-xonly'\n  | ':signature'\n  | ':control-block'\n  | { ':script': ScriptPatternElement[] };\n\ntype ScriptPatternElement = ScriptPatternConstant | ScriptPatternCapture;\n\n/**\n * Result for a successful script match\n */\ntype MatchResult = {\n  ':pubkey': Buffer[];\n  ':pubkey-xonly': Buffer[];\n  ':control-block': Buffer[];\n  ':signature': (Buffer | 0)[];\n  ':script': { buffer: Buffer; match: MatchResult }[];\n};\n\nfunction emptyMatchResult(): MatchResult {\n  return {\n    ':pubkey': [],\n    ':pubkey-xonly': [],\n    ':control-block': [],\n    ':signature': [],\n    ':script': [],\n  };\n}\n\nclass MatchError extends Error {\n  // this property is required to prohibit `return new Error()` when the return type demands `MatchError`\n  __type = 'MatchError';\n  constructor(message: string) {\n    super(message);\n  }\n\n  static forPatternElement(p: ScriptPatternElement): MatchError {\n    if (typeof p === 'object' && ':script' in p) {\n      return new MatchError(`error matching nested script`);\n    }\n    return new MatchError(`error matching ${p}`);\n  }\n}\n\n/**\n * @param script\n * @param pattern\n * @return MatchResult if script matches pattern. The result will contain the matched values.\n */\nfunction matchScript(script: DecompiledScript, pattern: ScriptPatternElement[]): MatchResult | MatchError {\n  /**\n   * Match a single script element with a ScriptPatternElement\n   */\n  function matchElement(e: Buffer | number, p: ScriptPatternElement): MatchResult | boolean {\n    switch (p) {\n      case 'OP_0':\n        return e === opcodes.OP_0 || (Buffer.isBuffer(e) && e.length === 0);\n      case 'OP_1':\n      case 'OP_2':\n      case 'OP_3':\n      case 'OP_CHECKMULTISIG':\n      case 'OP_CHECKSIG':\n      case 'OP_CHECKSIGVERIFY':\n        return e === opcodes[p];\n      case ':pubkey':\n        return Buffer.isBuffer(e) && (e.length === 33 || e.length === 65);\n      case ':pubkey-xonly':\n        return Buffer.isBuffer(e) && e.length === 32;\n      case ':signature':\n        return Buffer.isBuffer(e) || isPlaceholderSignature(e);\n      case ':control-block':\n        return Buffer.isBuffer(e) && isValidControlBock(e);\n      default:\n        throw new Error(`unknown pattern element ${p}`);\n    }\n  }\n\n  if (script.length !== pattern.length) {\n    return new MatchError(`length mismatch`);\n  }\n\n  // Go over each pattern element.\n  // Collect captures into a result object.\n  return pattern.reduce((obj: MatchResult | MatchError, p, i): MatchResult | MatchError => {\n    // if we had a previous mismatch, short-circuit\n    if (obj instanceof MatchError) {\n      return obj;\n    }\n\n    const e = script[i];\n\n    // for ':script' pattern elements, decompile script element and recurse\n    if (typeof p === 'object' && ':script' in p) {\n      if (!Buffer.isBuffer(e)) {\n        return new MatchError(`expected buffer for :script`);\n      }\n      const dec = bscript.decompile(e);\n      if (!dec) {\n        return new MatchError(`error decompiling nested script`);\n      }\n      const match = matchScript(dec, p[':script']);\n      if (match instanceof MatchError) {\n        return match;\n      }\n      obj[':script'].push({\n        buffer: e,\n        match,\n      });\n      return obj;\n    }\n\n    const match = matchElement(e, p);\n    if (!match) {\n      return MatchError.forPatternElement(p);\n    }\n\n    // if pattern element is a capture, add it to the result obj\n    if (p === ':signature' && e === 0) {\n      obj[p].push(e);\n    } else if (p in obj) {\n      if (!Buffer.isBuffer(e)) {\n        throw new Error(`invalid capture value`);\n      }\n      obj[p].push(e);\n    }\n\n    return obj;\n  }, emptyMatchResult());\n}\n\n/**\n * @param script\n * @param patterns\n * @return first match\n */\nfunction matchScriptSome(script: DecompiledScript, patterns: ScriptPatternElement[][]): MatchResult | MatchError {\n  for (const p of patterns) {\n    const m = matchScript(script, p);\n    if (m instanceof MatchError) {\n      continue;\n    }\n    return m;\n  }\n  return new MatchError(`no match for script`);\n}\n\ntype InputScripts<TScript, TWitness> = {\n  script: TScript;\n  witness: TWitness;\n};\n\ntype InputScriptsLegacy = InputScripts<DecompiledScript, null>;\ntype InputScriptsWrappedSegwit = InputScripts<DecompiledScript, Buffer[]>;\ntype InputScriptsNativeSegwit = InputScripts<null, Buffer[]>;\n\ntype InputScriptsUnknown = InputScripts<DecompiledScript | null, Buffer[] | null>;\n\ntype InputParser<T extends ParsedSignatureScriptP2shP2pk | ParsedSignatureScriptP2ms | ParsedSignatureScriptTaproot> = (\n  p: InputScriptsUnknown\n) => T | MatchError;\n\nexport type InputPubScript = Buffer;\n\ntype PubScriptParser<T extends ParsedPubScriptTaproot | ParsedPubScriptP2ms | ParsedPubScriptP2shP2pk> = (\n  p: InputPubScript,\n  t: ParsedScriptType\n) => T | MatchError;\n\nfunction isLegacy(p: InputScriptsUnknown): p is InputScriptsLegacy {\n  return Boolean(p.script && !p.witness);\n}\n\nfunction isWrappedSegwit(p: InputScriptsUnknown): p is InputScriptsWrappedSegwit {\n  return Boolean(p.script && p.witness);\n}\n\nfunction isNativeSegwit(p: InputScriptsUnknown): p is InputScriptsNativeSegwit {\n  return Boolean(!p.script && p.witness);\n}\n\nconst parseP2shP2pk: InputParser<ParsedSignatureScriptP2shP2pk> = (p) => {\n  if (!isLegacy(p)) {\n    return new MatchError(`expected legacy input`);\n  }\n  const match = matchScript(p.script, [':signature', { ':script': [':pubkey', 'OP_CHECKSIG'] }]);\n  if (match instanceof MatchError) {\n    return match;\n  }\n  return {\n    scriptType: 'p2shP2pk',\n    publicKeys: match[':script'][0].match[':pubkey'] as [Buffer],\n    signatures: match[':signature'] as [Buffer],\n  };\n};\n\nfunction parseP2ms(\n  decScript: DecompiledScript,\n  scriptType: 'p2sh' | 'p2shP2wsh' | 'p2wsh'\n): ParsedSignatureScriptP2ms | MatchError {\n  const pattern2Of3: ScriptPatternElement[] = ['OP_2', ':pubkey', ':pubkey', ':pubkey', 'OP_3', 'OP_CHECKMULTISIG'];\n\n  const match = matchScriptSome(decScript, [\n    /* full-signed, no placeholder signature */\n    ['OP_0', ':signature', ':signature', { ':script': pattern2Of3 }],\n    /* half-signed, placeholder signatures */\n    ['OP_0', ':signature', ':signature', ':signature', { ':script': pattern2Of3 }],\n  ]);\n  if (match instanceof MatchError) {\n    return match;\n  }\n\n  const [redeemScript] = match[':script'];\n\n  if (!isTriple(redeemScript.match[':pubkey'])) {\n    throw new Error(`invalid pubkey count`);\n  }\n\n  return {\n    scriptType,\n    publicKeys: redeemScript.match[':pubkey'],\n    pubScript: redeemScript.buffer,\n    signatures: match[':signature'] as ParsedSignatureScriptP2ms['signatures'],\n    redeemScript: scriptType === 'p2sh' ? redeemScript.buffer : undefined,\n    witnessScript: scriptType === 'p2shP2wsh' || scriptType === 'p2wsh' ? redeemScript.buffer : undefined,\n  };\n}\n\nconst parseP2sh2Of3: InputParser<ParsedSignatureScriptP2ms> = (p) => {\n  if (!isLegacy(p)) {\n    return new MatchError(`expected legacy input`);\n  }\n  return parseP2ms(p.script, 'p2sh');\n};\n\nconst parseP2shP2wsh2Of3: InputParser<ParsedSignatureScriptP2ms> = (p) => {\n  if (!isWrappedSegwit(p)) {\n    return new MatchError(`expected wrapped segwit input`);\n  }\n  return { ...parseP2ms(p.witness, 'p2shP2wsh'), redeemScript: p.script[0] as Buffer };\n};\n\nconst parseP2wsh2Of3: InputParser<ParsedSignatureScriptP2ms> = (p) => {\n  if (!isNativeSegwit(p)) {\n    return new MatchError(`expected native segwit`);\n  }\n  return parseP2ms(p.witness, 'p2wsh');\n};\n\nconst parseTaprootKeyPath2Of3: InputParser<ParsedSignatureScriptTaprootKeyPath> = (p) => {\n  if (!isNativeSegwit(p)) {\n    return new MatchError(`expected native segwit`);\n  }\n  const match = matchScript(p.witness, [':signature']);\n  if (match instanceof MatchError) {\n    return match;\n  }\n  const signatures = match[':signature'] as [Buffer];\n  if (isPlaceholderSignature(signatures[0])) {\n    throw new Error(`invalid taproot key path signature`);\n  }\n  return {\n    scriptType: 'taprootKeyPathSpend',\n    signatures,\n  };\n};\n\nconst parseTaprootScriptPath2Of3: InputParser<ParsedSignatureScriptTaproot> = (p) => {\n  if (!isNativeSegwit(p)) {\n    return new MatchError(`expected native segwit`);\n  }\n  // assumes no annex\n  const match = matchScript(p.witness, [\n    ':signature',\n    ':signature',\n    { ':script': [':pubkey-xonly', 'OP_CHECKSIGVERIFY', ':pubkey-xonly', 'OP_CHECKSIG'] },\n    ':control-block',\n  ]);\n  if (match instanceof MatchError) {\n    return match;\n  }\n  const [controlBlock] = match[':control-block'];\n  const scriptPathLevel = calculateScriptPathLevel(controlBlock);\n\n  const leafVersion = getLeafVersion(controlBlock);\n\n  return {\n    scriptType: 'taprootScriptPathSpend',\n    pubScript: match[':script'][0].buffer,\n    publicKeys: match[':script'][0].match[':pubkey-xonly'] as [Buffer, Buffer],\n    signatures: match[':signature'] as [Buffer, Buffer],\n    controlBlock,\n    scriptPathLevel,\n    leafVersion,\n  };\n};\n\n/**\n * Parse a transaction's signature script to obtain public keys, signatures, the sig script,\n * and other properties.\n *\n * Only supports script types used in BitGo transactions.\n *\n * @param input\n * @returns ParsedSignatureScript\n */\nexport function parseSignatureScript(\n  input: TxInput\n): ParsedSignatureScriptP2shP2pk | ParsedSignatureScriptP2ms | ParsedSignatureScriptTaproot {\n  const decScript = bscript.decompile(input.script);\n  const parsers = [\n    parseP2sh2Of3,\n    parseP2shP2wsh2Of3,\n    parseP2wsh2Of3,\n    parseTaprootKeyPath2Of3,\n    parseTaprootScriptPath2Of3,\n    parseP2shP2pk,\n  ] as const;\n  for (const f of parsers) {\n    const parsed = f({\n      script: decScript?.length === 0 ? null : decScript,\n      witness: input.witness.length === 0 ? null : input.witness,\n    });\n    if (parsed instanceof MatchError) {\n      continue;\n    }\n    return parsed;\n  }\n  throw new Error(`could not parse input`);\n}\n\nexport function parseSignatureScript2Of3(input: TxInput): ParsedSignatureScriptP2ms | ParsedSignatureScriptTaproot {\n  const result = parseSignatureScript(input);\n\n  if (\n    !isScriptType2Of3(result.scriptType) &&\n    result.scriptType !== 'taprootKeyPathSpend' &&\n    result.scriptType !== 'taprootScriptPathSpend'\n  ) {\n    throw new Error(`invalid script type`);\n  }\n\n  if (!result.signatures) {\n    throw new Error(`missing signatures`);\n  }\n  if (\n    result.scriptType !== 'taprootKeyPathSpend' &&\n    result.publicKeys.length !== 3 &&\n    (result.publicKeys.length !== 2 || result.scriptType !== 'taprootScriptPathSpend')\n  ) {\n    throw new Error(`unexpected pubkey count`);\n  }\n\n  return result as ParsedSignatureScriptP2ms | ParsedSignatureScriptTaproot;\n}\n\nconst parseP2shP2pkPubScript: PubScriptParser<ParsedPubScriptP2shP2pk> = (pubScript, scriptType) => {\n  if (scriptType !== 'p2shP2pk') {\n    throw new Error('invalid script type');\n  }\n  const match = matchScript([pubScript], [{ ':script': [':pubkey', 'OP_CHECKSIG'] }]);\n  if (match instanceof MatchError) {\n    return match;\n  }\n  const [script] = match[':script'];\n  return {\n    scriptType,\n    publicKeys: script.match[':pubkey'] as [Buffer],\n    pubScript: pubScript,\n    redeemScript: pubScript,\n  };\n};\n\nconst parseP2msPubScript: PubScriptParser<ParsedPubScriptP2ms> = (pubScript, scriptType) => {\n  if (scriptType === 'taprootScriptPathSpend' || scriptType === 'taprootKeyPathSpend' || scriptType === 'p2shP2pk') {\n    throw new Error('invalid script type');\n  }\n  const match = matchScript(\n    [pubScript],\n    [{ ':script': ['OP_2', ':pubkey', ':pubkey', ':pubkey', 'OP_3', 'OP_CHECKMULTISIG'] }]\n  );\n  if (match instanceof MatchError) {\n    return match;\n  }\n\n  const [redeemScript] = match[':script'];\n\n  if (!isTriple(redeemScript.match[':pubkey'])) {\n    throw new Error('invalid pubkey count');\n  }\n\n  return {\n    scriptType,\n    publicKeys: redeemScript.match[':pubkey'],\n    pubScript: redeemScript.buffer,\n    redeemScript: scriptType === 'p2sh' ? redeemScript.buffer : undefined,\n    witnessScript: scriptType === 'p2shP2wsh' || scriptType === 'p2wsh' ? redeemScript.buffer : undefined,\n  };\n};\n\nconst parseTaprootKeyPathPubScript: PubScriptParser<ParsedPubScriptTaprootKeyPath> = (pubScript, scriptType) => {\n  if (\n    scriptType === 'p2sh' ||\n    scriptType === 'p2wsh' ||\n    scriptType === 'p2shP2wsh' ||\n    scriptType === 'taprootScriptPathSpend' ||\n    scriptType === 'p2shP2pk'\n  ) {\n    throw new Error('invalid script type');\n  }\n  const match = matchScript([pubScript], [{ ':script': ['OP_1', ':pubkey-xonly'] }]);\n  if (match instanceof MatchError) {\n    return match;\n  }\n\n  const [script] = match[':script'];\n\n  return {\n    scriptType: 'taprootKeyPathSpend',\n    publicKeys: script.match[':pubkey-xonly'] as [Buffer],\n    pubScript: pubScript,\n  };\n};\n\nconst parseTaprootScriptPathPubScript: PubScriptParser<ParsedPubScriptTaprootScriptPath> = (pubScript, scriptType) => {\n  if (\n    scriptType === 'p2sh' ||\n    scriptType === 'p2wsh' ||\n    scriptType === 'p2shP2wsh' ||\n    scriptType === 'taprootKeyPathSpend' ||\n    scriptType === 'p2shP2pk'\n  ) {\n    throw new Error('invalid script type');\n  }\n  const match = matchScript(\n    [pubScript],\n    [{ ':script': [':pubkey-xonly', 'OP_CHECKSIGVERIFY', ':pubkey-xonly', 'OP_CHECKSIG'] }]\n  );\n  if (match instanceof MatchError) {\n    return match;\n  }\n\n  return {\n    scriptType,\n    pubScript: match[':script'][0].buffer,\n    publicKeys: match[':script'][0].match[':pubkey-xonly'] as [Buffer, Buffer],\n  };\n};\n\n/**\n * @return pubScript (scriptPubKey/redeemScript/witnessScript) is parsed.\n * P2SH => scriptType, pubScript (redeemScript), redeemScript, public keys\n * PW2SH => scriptType, pubScript (witnessScript), witnessScript, public keys.\n * P2SH-PW2SH => scriptType, pubScript (witnessScript), witnessScript, public keys.\n * taprootScriptPathSpend (P2TR and P2TRMUISG2 script path) => scriptType, pubScript, pub keys.\n * taprootKeyPathSpend (P2TRMUISG2 key path) => scriptType, pubScript (34-byte output script), pub key (tapOutputKey).\n */\nexport function parsePubScript2Of3(\n  inputPubScript: InputPubScript,\n  scriptType: 'taprootKeyPathSpend'\n): ParsedPubScriptTaprootKeyPath;\nexport function parsePubScript2Of3(\n  inputPubScript: InputPubScript,\n  scriptType: 'taprootScriptPathSpend'\n): ParsedPubScriptTaprootScriptPath;\nexport function parsePubScript2Of3(\n  inputPubScript: InputPubScript,\n  scriptType: 'p2sh' | 'p2shP2wsh' | 'p2wsh'\n): ParsedPubScriptP2ms;\nexport function parsePubScript2Of3(\n  inputPubScript: InputPubScript,\n  scriptType: ParsedScriptType2Of3\n): ParsedPubScriptP2ms | ParsedPubScriptTaproot;\nexport function parsePubScript2Of3(\n  inputPubScript: InputPubScript,\n  scriptType: ParsedScriptType2Of3\n): ParsedPubScriptP2ms | ParsedPubScriptTaproot {\n  const result =\n    scriptType === 'taprootKeyPathSpend'\n      ? parseTaprootKeyPathPubScript(inputPubScript, scriptType)\n      : scriptType === 'taprootScriptPathSpend'\n      ? parseTaprootScriptPathPubScript(inputPubScript, scriptType)\n      : parseP2msPubScript(inputPubScript, scriptType);\n\n  if (result instanceof MatchError) {\n    throw new Error(result.message);\n  }\n\n  if (\n    (result.scriptType === 'taprootKeyPathSpend' && result.publicKeys.length !== 1) ||\n    (result.scriptType === 'taprootScriptPathSpend' && result.publicKeys.length !== 2) ||\n    (isScriptType2Of3(result.scriptType) && result.publicKeys.length !== 3)\n  ) {\n    throw new Error('unexpected pubkey count');\n  }\n\n  return result;\n}\n\n/**\n * @return pubScript (scriptPubKey/redeemScript/witnessScript) is parsed.\n * P2SH => scriptType, pubScript (redeemScript), redeemScript, public keys\n * PW2SH => scriptType, pubScript (witnessScript), witnessScript, public keys.\n * P2SH-PW2SH => scriptType, pubScript (witnessScript), witnessScript, public keys.\n * taprootScriptPathSpend (P2TR and P2TRMUISG2 script path) => scriptType, pubScript, pub keys.\n * taprootKeyPathSpend (P2TRMUISG2 key path) => scriptType, pubScript (34-byte output script), pub key (tapOutputKey).\n * P2SH-P2PK => scriptType, pubScript, pub key, redeemScript.\n */\nexport function parsePubScript(\n  inputPubScript: InputPubScript,\n  scriptType: 'taprootKeyPathSpend'\n): ParsedPubScriptTaprootKeyPath;\nexport function parsePubScript(\n  inputPubScript: InputPubScript,\n  scriptType: 'taprootScriptPathSpend'\n): ParsedPubScriptTaprootScriptPath;\nexport function parsePubScript(inputPubScript: InputPubScript, scriptType: 'p2shP2pk'): ParsedPubScriptP2shP2pk;\nexport function parsePubScript(\n  inputPubScript: InputPubScript,\n  scriptType: 'p2sh' | 'p2shP2wsh' | 'p2wsh'\n): ParsedPubScriptP2ms;\nexport function parsePubScript(\n  inputPubScript: InputPubScript,\n  scriptType: ParsedScriptType\n): ParsedPubScriptP2ms | ParsedPubScriptTaproot | ParsedPubScriptP2shP2pk;\nexport function parsePubScript(\n  inputPubScript: InputPubScript,\n  scriptType: ParsedScriptType\n): ParsedPubScriptP2ms | ParsedPubScriptTaproot | ParsedPubScriptP2shP2pk {\n  const result =\n    scriptType === 'p2shP2pk'\n      ? parseP2shP2pkPubScript(inputPubScript, scriptType)\n      : parsePubScript2Of3(inputPubScript, scriptType);\n\n  if (result instanceof MatchError) {\n    throw new Error(result.message);\n  }\n\n  if (result.scriptType === 'p2shP2pk' && result.publicKeys.length !== 1) {\n    throw new Error('unexpected pubkey count');\n  }\n\n  return result;\n}\n\nexport function getChainAndIndexFromPath(path: string): { chain: number; index: number } {\n  const parts = path.split('/');\n  if (parts.length <= 2) {\n    throw new Error(`invalid path \"${path}\"`);\n  }\n  const chain = Number(parts[parts.length - 2]);\n  const index = Number(parts[parts.length - 1]);\n  if (isNaN(chain) || isNaN(index)) {\n    throw new Error(`Could not parse chain and index into numbers from path ${path}`);\n  }\n  if (chain < 0 || index < 0) {\n    throw new Error(`chain and index must be non-negative`);\n  }\n\n  return { chain, index };\n}\n"]}
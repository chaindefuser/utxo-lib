{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/PsbtUtil.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/PsbtUtil.ts"],"names":[],"mappings":"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","sourcesContent":["import { decodeProprietaryKey, ProprietaryKey } from 'bip174/src/lib/proprietaryKeyVal';\nimport { PsbtInput } from 'bip174/src/lib/interfaces';\nimport { Psbt } from 'bitcoinjs-lib/src/psbt';\n\n/**\n * bitgo proprietary key identifier\n */\nexport const PSBT_PROPRIETARY_IDENTIFIER = 'BITGO';\n\n/**\n * subtype for proprietary keys that bitgo uses\n */\nexport enum ProprietaryKeySubtype {\n  ZEC_CONSENSUS_BRANCH_ID = 0x00,\n  MUSIG2_PARTICIPANT_PUB_KEYS = 0x01,\n  MUSIG2_PUB_NONCE = 0x02,\n  MUSIG2_PARTIAL_SIG = 0x03,\n}\n\n/**\n * Psbt proprietary keydata object.\n * <compact size uint identifier length> <bytes identifier> <compact size uint subtype> <bytes subkeydata>\n * => <bytes valuedata>\n */\nexport interface ProprietaryKeyValue {\n  key: ProprietaryKey;\n  value: Buffer;\n}\n\n/**\n * Psbt proprietary keydata object search fields.\n * <compact size uint identifier length> <bytes identifier> <compact size uint subtype> <bytes subkeydata>\n */\nexport interface ProprietaryKeySearch {\n  identifier: string;\n  subtype?: number;\n  keydata?: Buffer;\n  identifierEncoding?: BufferEncoding;\n}\n\n/**\n * Search any data from psbt proprietary key value against keydata.\n * Default identifierEncoding is utf-8 for identifier.\n */\nexport function getPsbtInputProprietaryKeyVals(\n  input: PsbtInput,\n  keySearch?: ProprietaryKeySearch\n): ProprietaryKeyValue[] {\n  if (!input.unknownKeyVals?.length) {\n    return [];\n  }\n  if (keySearch && keySearch.subtype === undefined && Buffer.isBuffer(keySearch.keydata)) {\n    throw new Error('invalid proprietary key search filter combination. subtype is required');\n  }\n  const keyVals = input.unknownKeyVals.map(({ key, value }, i) => {\n    return { key: decodeProprietaryKey(key), value };\n  });\n  return keyVals.filter((keyVal) => {\n    return (\n      keySearch === undefined ||\n      (keySearch.identifier === keyVal.key.identifier &&\n        (keySearch.subtype === undefined ||\n          (keySearch.subtype === keyVal.key.subtype &&\n            (!Buffer.isBuffer(keySearch.keydata) || keySearch.keydata.equals(keyVal.key.keydata)))))\n    );\n  });\n}\n\n/**\n * @return partialSig/tapScriptSig/MUSIG2_PARTIAL_SIG count iff input is not finalized\n */\nexport function getPsbtInputSignatureCount(input: PsbtInput): number {\n  if (isPsbtInputFinalized(input)) {\n    throw new Error('Input is already finalized');\n  }\n  return Math.max(\n    Array.isArray(input.partialSig) ? input.partialSig.length : 0,\n    Array.isArray(input.tapScriptSig) ? input.tapScriptSig.length : 0,\n    getPsbtInputProprietaryKeyVals(input, {\n      identifier: PSBT_PROPRIETARY_IDENTIFIER,\n      subtype: ProprietaryKeySubtype.MUSIG2_PARTIAL_SIG,\n    }).length\n  );\n}\n\n/**\n * @return true iff PSBT input is finalized\n */\nexport function isPsbtInputFinalized(input: PsbtInput): boolean {\n  return Buffer.isBuffer(input.finalScriptSig) || Buffer.isBuffer(input.finalScriptWitness);\n}\n\n/**\n * @return true iff data starts with magic PSBT byte sequence\n * @param data byte array or hex string\n * */\nexport function isPsbt(data: Buffer | string): boolean {\n  // https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki#specification\n  // 0x70736274 - ASCII for 'psbt'. 0xff - separator\n  if (typeof data === 'string') {\n    if (data.length < 10) {\n      return false;\n    }\n    data = Buffer.from(data.slice(0, 10), 'hex');\n  }\n  return 5 <= data.length && data.readUInt32BE(0) === 0x70736274 && data.readUInt8(4) === 0xff;\n}\n\n/**\n * First checks if the input is already a buffer that starts with the magic PSBT byte sequence.\n * If not, it checks if the input is a base64- or hex-encoded string that starts with PSBT header.\n *\n * This function is useful when reading a file that could be in any of the above formats or when\n * dealing with a request that could contain a hex or base64 encoded PSBT.\n *\n * @param data\n * @return buffer that starts with the magic PSBT byte sequence\n * @throws Error when conversion is not possible\n */\nexport function toPsbtBuffer(data: Buffer | string): Buffer {\n  if (Buffer.isBuffer(data)) {\n    // we are dealing with a buffer that looks like a psbt already\n    if (isPsbt(data)) {\n      return data;\n    }\n\n    // we could be dealing with a buffer that could be a hex or base64 encoded psbt\n    data = data.toString('ascii');\n  }\n\n  if (typeof data === 'string') {\n    const encodings = ['hex', 'base64'] as const;\n    for (const encoding of encodings) {\n      let buffer: Buffer;\n      try {\n        buffer = Buffer.from(data, encoding);\n      } catch (e) {\n        continue;\n      }\n      if (isPsbt(buffer)) {\n        return buffer;\n      }\n    }\n\n    throw new Error(`data is not in any of the following formats: ${encodings.join(', ')}`);\n  }\n\n  throw new Error('data must be a buffer or a string');\n}\n\n/**\n * This function allows signing or validating a psbt with non-segwit inputs those do not contain nonWitnessUtxo.\n */\nexport function withUnsafeNonSegwit<T>(psbt: Psbt, fn: () => T, unsafe = true): T {\n  (psbt as any).__CACHE.__UNSAFE_SIGN_NONSEGWIT = unsafe;\n  (psbt as any).__CACHE.__WARN_UNSAFE_SIGN_NONSEGWIT = !unsafe;\n  try {\n    return fn();\n  } finally {\n    (psbt as any).__CACHE.__UNSAFE_SIGN_NONSEGWIT = false;\n    (psbt as any).__CACHE.__WARN_UNSAFE_SIGN_NONSEGWIT = true;\n  }\n}\n"]}
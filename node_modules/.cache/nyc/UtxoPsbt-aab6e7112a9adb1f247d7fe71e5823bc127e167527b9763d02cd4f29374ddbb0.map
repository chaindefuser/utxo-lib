{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/UtxoPsbt.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/UtxoPsbt.ts"],"names":[],"mappings":"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","sourcesContent":["import * as assert from 'assert';\nimport { Psbt as PsbtBase } from 'bip174';\nimport {\n  Bip32Derivation,\n  PsbtInput,\n  TapBip32Derivation,\n  Transaction as ITransaction,\n  TransactionFromBuffer,\n} from 'bip174/src/lib/interfaces';\nimport { checkForInput } from 'bip174/src/lib/utils';\nimport { BufferWriter, varuint } from 'bitcoinjs-lib/src/bufferutils';\nimport { SessionKey } from '@brandonblack/musig';\nimport { BIP32Factory, BIP32Interface } from 'bip32';\nimport * as bs58check from 'bs58check';\nimport { decodeProprietaryKey, encodeProprietaryKey } from 'bip174/src/lib/proprietaryKeyVal';\n\nimport {\n  taproot,\n  HDSigner,\n  Signer,\n  Psbt,\n  PsbtTransaction,\n  Transaction,\n  TxOutput,\n  Network,\n  ecc as eccLib,\n  getMainnet,\n  networks,\n} from '..';\nimport { UtxoTransaction } from './UtxoTransaction';\nimport { getOutputIdForInput } from './Unspent';\nimport { isSegwit } from './psbt/scriptTypes';\nimport { unsign } from './psbt/fromHalfSigned';\nimport { toXOnlyPublicKey } from './outputScripts';\nimport { parsePubScript2Of3 } from './parseInput';\nimport {\n  createMusig2SigningSession,\n  encodePsbtMusig2PartialSig,\n  encodePsbtMusig2PubNonce,\n  musig2PartialSign,\n  parsePsbtMusig2Nonces,\n  parsePsbtMusig2Participants,\n  PsbtMusig2Participants,\n  assertPsbtMusig2Nonces,\n  assertPsbtMusig2Participants,\n  Musig2NonceStore,\n  PsbtMusig2PubNonce,\n  parsePsbtMusig2PartialSigs,\n  musig2PartialSigVerify,\n  musig2AggregateSigs,\n  getSigHashTypeFromSigs,\n  musig2DeterministicSign,\n  createMusig2DeterministicNonce,\n} from './Musig2';\nimport { isTriple, isTuple, Triple, Tuple } from './types';\nimport { getTaprootOutputKey } from '../taproot';\nimport {\n  getPsbtInputProprietaryKeyVals,\n  getPsbtInputSignatureCount,\n  ProprietaryKeySearch,\n  ProprietaryKeySubtype,\n  ProprietaryKeyValue,\n  PSBT_PROPRIETARY_IDENTIFIER,\n} from './PsbtUtil';\n\ntype SignatureParams = {\n  /** When true, and add the second (last) nonce and signature for a taproot key\n   * path spend deterministically. Throws an error if done for the first nonce/signature\n   * of a taproot keypath spend. Ignore for all other input types.\n   */\n  deterministic: boolean;\n  /** Allowed sighash types */\n  sighashTypes: number[];\n};\n\nfunction defaultSighashTypes(): number[] {\n  return [Transaction.SIGHASH_DEFAULT, Transaction.SIGHASH_ALL];\n}\n\nfunction addForkIdToSighashesIfNeeded(network: Network, sighashTypes: number[]): number[] {\n  switch (getMainnet(network)) {\n    case networks.bitcoincash:\n    case networks.bitcoinsv:\n    case networks.bitcoingold:\n    case networks.ecash:\n      return [...sighashTypes, ...sighashTypes.map((s) => s | UtxoTransaction.SIGHASH_FORKID)];\n    default:\n      return sighashTypes;\n  }\n}\n\nfunction toSignatureParams(network: Network, v?: Partial<SignatureParams> | number[]): SignatureParams {\n  if (Array.isArray(v)) return toSignatureParams(network, { sighashTypes: v });\n  const defaultSignatureParams = { deterministic: false, sighashTypes: defaultSighashTypes() };\n  const ret = { ...defaultSignatureParams, ...v };\n  ret.sighashTypes = addForkIdToSighashesIfNeeded(network, ret.sighashTypes);\n  return ret;\n}\n\n/**\n * @param a\n * @param b\n * @returns true if the two public keys are equal ignoring the y coordinate.\n */\nfunction equalPublicKeyIgnoreY(a: Buffer, b: Buffer): boolean {\n  return toXOnlyPublicKey(a).equals(toXOnlyPublicKey(b));\n}\n\nexport interface HDTaprootSigner extends HDSigner {\n  /**\n   * The path string must match /^m(\\/\\d+'?)+$/\n   * ex. m/44'/0'/0'/1/23 levels with ' must be hard derivations\n   */\n  derivePath(path: string): HDTaprootSigner;\n  /**\n   * Input hash (the \"message digest\") for the signature algorithm\n   * Return a 64 byte signature (32 byte r and 32 byte s in that order)\n   */\n  signSchnorr(hash: Buffer): Buffer;\n}\n\n/**\n * HD signer object for taproot p2tr musig2 key path sign\n */\nexport interface HDTaprootMusig2Signer extends HDSigner {\n  /**\n   * Musig2 requires signer's 32-bytes private key to be passed to it.\n   */\n  privateKey: Buffer;\n\n  /**\n   * The path string must match /^m(\\/\\d+'?)+$/\n   * ex. m/44'/0'/0'/1/23 levels with ' must be hard derivations\n   */\n  derivePath(path: string): HDTaprootMusig2Signer;\n}\n\nexport interface SchnorrSigner {\n  publicKey: Buffer;\n  signSchnorr(hash: Buffer): Buffer;\n}\n\nexport interface Musig2Signer {\n  publicKey: Buffer;\n  privateKey: Buffer;\n}\n\nexport interface TaprootSigner {\n  leafHashes: Buffer[];\n  signer: SchnorrSigner;\n}\n\nexport interface PsbtOpts {\n  network: Network;\n  maximumFeeRate?: number; // [sat/byte]\n  bip32PathsAbsolute?: boolean;\n}\n\n// TODO: upstream does `checkInputsForPartialSigs` before doing things like\n// `setVersion`. Our inputs could have tapscriptsigs (or in future tapkeysigs)\n// and not fail that check. Do we want to do anything about that?\nexport class UtxoPsbt<Tx extends UtxoTransaction<bigint> = UtxoTransaction<bigint>> extends Psbt {\n  private nonceStore = new Musig2NonceStore();\n\n  protected static transactionFromBuffer(buffer: Buffer, network: Network): UtxoTransaction<bigint> {\n    return UtxoTransaction.fromBuffer<bigint>(buffer, false, 'bigint', network);\n  }\n\n  static createPsbt(opts: PsbtOpts, data?: PsbtBase): UtxoPsbt {\n    return new UtxoPsbt(\n      opts,\n      data || new PsbtBase(new PsbtTransaction({ tx: new UtxoTransaction<bigint>(opts.network) }))\n    );\n  }\n\n  static fromBuffer(buffer: Buffer, opts: PsbtOpts): UtxoPsbt {\n    const transactionFromBuffer: TransactionFromBuffer = (buffer: Buffer): ITransaction => {\n      const tx = this.transactionFromBuffer(buffer, opts.network);\n      return new PsbtTransaction({ tx });\n    };\n    const psbtBase = PsbtBase.fromBuffer(buffer, transactionFromBuffer, {\n      bip32PathsAbsolute: opts.bip32PathsAbsolute,\n    });\n    const psbt = this.createPsbt(opts, psbtBase);\n    // Upstream checks for duplicate inputs here, but it seems to be of dubious value.\n    return psbt;\n  }\n\n  static fromHex(data: string, opts: PsbtOpts): UtxoPsbt {\n    return this.fromBuffer(Buffer.from(data, 'hex'), opts);\n  }\n\n  /**\n   * @param parent - Parent key. Matched with `bip32Derivations` using `fingerprint` property.\n   * @param bip32Derivations - possible derivations for input or output\n   * @param ignoreY - when true, ignore the y coordinate when matching public keys\n   * @return derived bip32 node if matching derivation is found, undefined if none is found\n   * @throws Error if more than one match is found\n   */\n  static deriveKeyPair(\n    parent: BIP32Interface,\n    bip32Derivations: Bip32Derivation[],\n    { ignoreY }: { ignoreY: boolean }\n  ): BIP32Interface | undefined {\n    const matchingDerivations = bip32Derivations.filter((bipDv) => {\n      return bipDv.masterFingerprint.equals(parent.fingerprint);\n    });\n\n    if (!matchingDerivations.length) {\n      // No fingerprint match\n      return undefined;\n    }\n\n    if (matchingDerivations.length !== 1) {\n      throw new Error(\n        `more than one matching derivation for fingerprint ${parent.fingerprint.toString('hex')}: ${\n          matchingDerivations.length\n        }`\n      );\n    }\n\n    const [derivation] = matchingDerivations;\n    const node = parent.derivePath(derivation.path);\n\n    if (!node.publicKey.equals(derivation.pubkey)) {\n      if (!ignoreY || !equalPublicKeyIgnoreY(node.publicKey, derivation.pubkey)) {\n        throw new Error('pubkey did not match bip32Derivation');\n      }\n    }\n\n    return node;\n  }\n\n  static deriveKeyPairForInput(bip32: BIP32Interface, input: PsbtInput): Buffer | undefined {\n    return input.tapBip32Derivation?.length\n      ? UtxoPsbt.deriveKeyPair(bip32, input.tapBip32Derivation, { ignoreY: true })?.publicKey\n      : input.bip32Derivation?.length\n      ? UtxoPsbt.deriveKeyPair(bip32, input.bip32Derivation, { ignoreY: false })?.publicKey\n      : bip32?.publicKey;\n  }\n\n  get network(): Network {\n    return this.tx.network;\n  }\n\n  toHex(): string {\n    return this.toBuffer().toString('hex');\n  }\n\n  /**\n   * It is expensive to attempt to compute every output address using psbt.txOutputs[outputIndex]\n   * to then just get the script. Here, we are doing the same thing as what txOutputs() does in\n   * bitcoinjs-lib, but without iterating over each output.\n   * @param outputIndex\n   * @returns output script at the given index\n   */\n  getOutputScript(outputIndex: number): Buffer {\n    return (this as any).__CACHE.__TX.outs[outputIndex].script as Buffer;\n  }\n\n  getNonWitnessPreviousTxids(): string[] {\n    const txInputs = this.txInputs; // These are somewhat costly to extract\n    const txidSet = new Set<string>();\n    this.data.inputs.forEach((input, index) => {\n      if (!input.witnessUtxo) {\n        throw new Error('Must have witness UTXO for all inputs');\n      }\n      if (!isSegwit(input.witnessUtxo.script, input.redeemScript)) {\n        txidSet.add(getOutputIdForInput(txInputs[index]).txid);\n      }\n    });\n    // @ts-ignore\n    return [...txidSet];\n  }\n\n  addNonWitnessUtxos(txBufs: Record<string, Buffer>): this {\n    const txInputs = this.txInputs; // These are somewhat costly to extract\n    this.data.inputs.forEach((input, index) => {\n      if (!input.witnessUtxo) {\n        throw new Error('Must have witness UTXO for all inputs');\n      }\n      if (!isSegwit(input.witnessUtxo.script, input.redeemScript)) {\n        const { txid } = getOutputIdForInput(txInputs[index]);\n        if (txBufs[txid] === undefined) {\n          throw new Error('Not all required previous transactions provided');\n        }\n        this.updateInput(index, { nonWitnessUtxo: txBufs[txid] });\n      }\n    });\n    return this;\n  }\n\n  static fromTransaction(transaction: UtxoTransaction<bigint>, prevOutputs: TxOutput<bigint>[]): UtxoPsbt {\n    if (prevOutputs.length !== transaction.ins.length) {\n      throw new Error(\n        `Transaction has ${transaction.ins.length} inputs, but ${prevOutputs.length} previous outputs provided`\n      );\n    }\n    const clonedTransaction = transaction.clone();\n    const updates = unsign(clonedTransaction, prevOutputs);\n\n    const psbtBase = new PsbtBase(new PsbtTransaction({ tx: clonedTransaction }));\n    clonedTransaction.ins.forEach(() => psbtBase.inputs.push({ unknownKeyVals: [] }));\n    clonedTransaction.outs.forEach(() => psbtBase.outputs.push({ unknownKeyVals: [] }));\n    const psbt = this.createPsbt({ network: transaction.network }, psbtBase);\n\n    updates.forEach((update, index) => {\n      psbt.updateInput(index, update);\n      psbt.updateInput(index, { witnessUtxo: { script: prevOutputs[index].script, value: prevOutputs[index].value } });\n    });\n\n    return psbt;\n  }\n\n  getUnsignedTx(): UtxoTransaction<bigint> {\n    return this.tx.clone();\n  }\n\n  protected static newTransaction(network: Network): UtxoTransaction<bigint> {\n    return new UtxoTransaction<bigint>(network);\n  }\n\n  protected get tx(): Tx {\n    return (this.data.globalMap.unsignedTx as PsbtTransaction).tx as Tx;\n  }\n\n  protected checkForSignatures(propName?: string): void {\n    this.data.inputs.forEach((input) => {\n      if (input.tapScriptSig?.length || input.tapKeySig || input.partialSig?.length) {\n        throw new Error(`Cannot modify ${propName ?? 'transaction'} - signatures exist.`);\n      }\n    });\n  }\n\n  /**\n   * @returns true if the input at inputIndex is a taproot key path.\n   * Checks for presence of minimum required key path input fields and absence of any script path only input fields.\n   */\n  isTaprootKeyPathInput(inputIndex: number): boolean {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    return (\n      !!input.tapInternalKey &&\n      !!input.tapMerkleRoot &&\n      !(\n        input.tapLeafScript?.length ||\n        input.tapScriptSig?.length ||\n        input.tapBip32Derivation?.some((v) => v.leafHashes.length)\n      )\n    );\n  }\n\n  /**\n   * @returns true if the input at inputIndex is a taproot script path.\n   * Checks for presence of minimum required script path input fields and absence of any key path only input fields.\n   */\n  isTaprootScriptPathInput(inputIndex: number): boolean {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    return (\n      !!input.tapLeafScript?.length &&\n      !(\n        this.getProprietaryKeyVals(inputIndex, {\n          identifier: PSBT_PROPRIETARY_IDENTIFIER,\n          subtype: ProprietaryKeySubtype.MUSIG2_PARTICIPANT_PUB_KEYS,\n        }).length ||\n        this.getProprietaryKeyVals(inputIndex, {\n          identifier: PSBT_PROPRIETARY_IDENTIFIER,\n          subtype: ProprietaryKeySubtype.MUSIG2_PUB_NONCE,\n        }).length ||\n        this.getProprietaryKeyVals(inputIndex, {\n          identifier: PSBT_PROPRIETARY_IDENTIFIER,\n          subtype: ProprietaryKeySubtype.MUSIG2_PARTIAL_SIG,\n        }).length\n      )\n    );\n  }\n\n  /**\n   * @returns true if the input at inputIndex is a taproot\n   */\n  isTaprootInput(inputIndex: number): boolean {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const isP2TR = (script: Buffer): boolean => {\n      try {\n        getTaprootOutputKey(script);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    };\n    return !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      input.tapLeafScript?.length ||\n      input.tapBip32Derivation?.length ||\n      input.tapScriptSig?.length ||\n      this.getProprietaryKeyVals(inputIndex, {\n        identifier: PSBT_PROPRIETARY_IDENTIFIER,\n        subtype: ProprietaryKeySubtype.MUSIG2_PARTICIPANT_PUB_KEYS,\n      }).length ||\n      this.getProprietaryKeyVals(inputIndex, {\n        identifier: PSBT_PROPRIETARY_IDENTIFIER,\n        subtype: ProprietaryKeySubtype.MUSIG2_PUB_NONCE,\n      }).length ||\n      this.getProprietaryKeyVals(inputIndex, {\n        identifier: PSBT_PROPRIETARY_IDENTIFIER,\n        subtype: ProprietaryKeySubtype.MUSIG2_PARTIAL_SIG,\n      }).length ||\n      (input.witnessUtxo && isP2TR(input.witnessUtxo.script))\n    );\n  }\n\n  private isMultisigTaprootScript(script: Buffer): boolean {\n    try {\n      parsePubScript2Of3(script, 'taprootScriptPathSpend');\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  /**\n   * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts\n   */\n  finalizeAllInputs(): this {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    this.data.inputs.map((input, idx) => {\n      if (input.tapLeafScript?.length) {\n        return this.isMultisigTaprootScript(input.tapLeafScript[0].script)\n          ? this.finalizeTaprootInput(idx)\n          : this.finalizeTapInputWithSingleLeafScriptAndSignature(idx);\n      } else if (this.isTaprootKeyPathInput(idx)) {\n        return this.finalizeTaprootMusig2Input(idx);\n      }\n      return this.finalizeInput(idx);\n    });\n    return this;\n  }\n\n  finalizeTaprootInput(inputIndex: number): this {\n    const sanitizeSignature = (sig: Buffer) => {\n      const sighashType = sig.length === 64 ? Transaction.SIGHASH_DEFAULT : sig.readUInt8(sig.length - 1);\n      const inputSighashType = input.sighashType === undefined ? Transaction.SIGHASH_DEFAULT : input.sighashType;\n      assert(sighashType === inputSighashType, 'signature sighash does not match input sighash type');\n      // TODO BTC-663 This should be fixed in platform. This is just a workaround fix.\n      return sighashType === Transaction.SIGHASH_DEFAULT && sig.length === 65 ? sig.slice(0, 64) : sig;\n    };\n    const input = checkForInput(this.data.inputs, inputIndex);\n    // witness = control-block script first-sig second-sig\n    if (input.tapLeafScript?.length !== 1) {\n      throw new Error('Only one leaf script supported for finalizing');\n    }\n    const { controlBlock, script } = input.tapLeafScript[0];\n    const witness: Buffer[] = [script, controlBlock];\n    const [pubkey1, pubkey2] = parsePubScript2Of3(script, 'taprootScriptPathSpend').publicKeys;\n    for (const pk of [pubkey1, pubkey2]) {\n      const sig = input.tapScriptSig?.find(({ pubkey }) => equalPublicKeyIgnoreY(pk, pubkey));\n      if (!sig) {\n        throw new Error('Could not find signatures in Script Sig.');\n      }\n      witness.unshift(sanitizeSignature(sig.signature));\n    }\n\n    const witnessLength = witness.reduce((s, b) => s + b.length + varuint.encodingLength(b.length), 1);\n\n    const bufferWriter = BufferWriter.withCapacity(witnessLength);\n    bufferWriter.writeVector(witness);\n    const finalScriptWitness = bufferWriter.end();\n\n    this.data.updateInput(inputIndex, { finalScriptWitness });\n    this.data.clearFinalizedInput(inputIndex);\n\n    return this;\n  }\n\n  /**\n   * Finalizes a taproot musig2 input by aggregating all partial sigs.\n   * IMPORTANT: Always call validate* function before finalizing.\n   */\n  finalizeTaprootMusig2Input(inputIndex: number): this {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const partialSigs = parsePsbtMusig2PartialSigs(input);\n    if (partialSigs?.length !== 2) {\n      throw new Error(`invalid number of partial signatures ${partialSigs ? partialSigs.length : 0} to finalize`);\n    }\n    const { partialSigs: pSigs, sigHashType } = getSigHashTypeFromSigs(partialSigs);\n    const { sessionKey } = this.getMusig2SessionKey(inputIndex, sigHashType);\n\n    const aggSig = musig2AggregateSigs(\n      pSigs.map((pSig) => pSig.partialSig),\n      sessionKey\n    );\n\n    const sig = sigHashType === Transaction.SIGHASH_DEFAULT ? aggSig : Buffer.concat([aggSig, Buffer.of(sigHashType)]);\n\n    // single signature with 64/65 bytes size is script witness for key path spend\n    const bufferWriter = BufferWriter.withCapacity(1 + varuint.encodingLength(sig.length) + sig.length);\n    bufferWriter.writeVector([sig]);\n    const finalScriptWitness = bufferWriter.end();\n\n    this.data.updateInput(inputIndex, { finalScriptWitness });\n    this.data.clearFinalizedInput(inputIndex);\n    // deleting only BitGo proprietary key values.\n    this.deleteProprietaryKeyVals(inputIndex, { identifier: PSBT_PROPRIETARY_IDENTIFIER });\n    return this;\n  }\n\n  finalizeTapInputWithSingleLeafScriptAndSignature(inputIndex: number): this {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (input.tapLeafScript?.length !== 1) {\n      throw new Error('Only one leaf script supported for finalizing');\n    }\n    if (input.tapScriptSig?.length !== 1) {\n      throw new Error('Could not find signatures in Script Sig.');\n    }\n\n    const { controlBlock, script } = input.tapLeafScript[0];\n    const witness: Buffer[] = [input.tapScriptSig[0].signature, script, controlBlock];\n    const witnessLength = witness.reduce((s, b) => s + b.length + varuint.encodingLength(b.length), 1);\n\n    const bufferWriter = BufferWriter.withCapacity(witnessLength);\n    bufferWriter.writeVector(witness);\n    const finalScriptWitness = bufferWriter.end();\n\n    this.data.updateInput(inputIndex, { finalScriptWitness });\n    this.data.clearFinalizedInput(inputIndex);\n\n    return this;\n  }\n\n  /**\n   * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts\n   *\n   * Unlike the function it overrides, this does not take a validator. In BitGo\n   * context, we know how we want to validate so we just hard code the right\n   * validator.\n   */\n  validateSignaturesOfAllInputs(): boolean {\n    checkForInput(this.data.inputs, 0); // making sure we have at least one\n    const results = this.data.inputs.map((input, idx) => {\n      return this.validateSignaturesOfInputCommon(idx);\n    });\n    return results.reduce((final, res) => res && final, true);\n  }\n\n  /**\n   * @returns true iff any matching valid signature is found for a derived pub key from given HD key pair.\n   */\n  validateSignaturesOfInputHD(inputIndex: number, hdKeyPair: BIP32Interface): boolean {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const pubKey = UtxoPsbt.deriveKeyPairForInput(hdKeyPair, input);\n    if (!pubKey) {\n      throw new Error('can not derive from HD key pair');\n    }\n    return this.validateSignaturesOfInputCommon(inputIndex, pubKey);\n  }\n\n  /**\n   * @returns true iff any valid signature(s) are found from bip32 data of PSBT or for given pub key.\n   */\n  validateSignaturesOfInputCommon(inputIndex: number, pubkey?: Buffer): boolean {\n    try {\n      if (this.isTaprootScriptPathInput(inputIndex)) {\n        return this.validateTaprootSignaturesOfInput(inputIndex, pubkey);\n      } else if (this.isTaprootKeyPathInput(inputIndex)) {\n        return this.validateTaprootMusig2SignaturesOfInput(inputIndex, pubkey);\n      }\n      return this.validateSignaturesOfInput(inputIndex, (p, m, s) => eccLib.verify(m, p, s, true), pubkey);\n    } catch (err) {\n      // Not an elegant solution. Might need upstream changes like custom error types.\n      if (err.message === 'No signatures for this pubkey') {\n        return false;\n      }\n      throw err;\n    }\n  }\n\n  private getMusig2SessionKey(\n    inputIndex: number,\n    sigHashType: number\n  ): {\n    participants: PsbtMusig2Participants;\n    nonces: Tuple<PsbtMusig2PubNonce>;\n    hash: Buffer;\n    sessionKey: SessionKey;\n  } {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (!input.tapInternalKey || !input.tapMerkleRoot) {\n      throw new Error('both tapInternalKey and tapMerkleRoot are required');\n    }\n\n    const participants = this.getMusig2Participants(inputIndex, input.tapInternalKey, input.tapMerkleRoot);\n    const nonces = this.getMusig2Nonces(inputIndex, participants);\n\n    const { hash } = this.getTaprootHashForSig(inputIndex, [sigHashType]);\n\n    const sessionKey = createMusig2SigningSession({\n      pubNonces: [nonces[0].pubNonce, nonces[1].pubNonce],\n      pubKeys: participants.participantPubKeys,\n      txHash: hash,\n      internalPubKey: input.tapInternalKey,\n      tapTreeRoot: input.tapMerkleRoot,\n    });\n    return { participants, nonces, hash, sessionKey };\n  }\n\n  /**\n   * @returns true for following cases.\n   * If valid musig2 partial signatures exists for both 2 keys, it will also verify aggregated sig\n   * for aggregated tweaked key (output key), otherwise only verifies partial sig.\n   * If pubkey is passed in input, it will check sig only for that pubkey,\n   * if no sig exits for such key, throws error.\n   * For invalid state of input data, it will throw errors.\n   */\n  validateTaprootMusig2SignaturesOfInput(inputIndex: number, pubkey?: Buffer): boolean {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const partialSigs = parsePsbtMusig2PartialSigs(input);\n    if (!partialSigs) {\n      throw new Error(`No signatures to validate`);\n    }\n\n    let myPartialSigs = partialSigs;\n    if (pubkey) {\n      myPartialSigs = partialSigs.filter((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, pubkey));\n      if (myPartialSigs?.length < 1) {\n        throw new Error('No signatures for this pubkey');\n      }\n    }\n\n    const { partialSigs: mySigs, sigHashType } = getSigHashTypeFromSigs(myPartialSigs);\n    const { participants, nonces, hash, sessionKey } = this.getMusig2SessionKey(inputIndex, sigHashType);\n\n    const results = mySigs.map((mySig) => {\n      const myNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, mySig.participantPubKey));\n      if (!myNonce) {\n        throw new Error('Found no pub nonce for pubkey');\n      }\n      return musig2PartialSigVerify(mySig.partialSig, mySig.participantPubKey, myNonce.pubNonce, sessionKey);\n    });\n\n    // For valid single sig or 1 or 2 failure sigs, no need to validate aggregated sig. So skip.\n    const result = results.every((res) => res);\n    if (!result || mySigs.length < 2) {\n      return result;\n    }\n\n    const aggSig = musig2AggregateSigs(\n      mySigs.map((mySig) => mySig.partialSig),\n      sessionKey\n    );\n\n    return eccLib.verifySchnorr(hash, participants.tapOutputKey, aggSig);\n  }\n\n  validateTaprootSignaturesOfInput(inputIndex: number, pubkey?: Buffer): boolean {\n    const input = this.data.inputs[inputIndex];\n    const tapSigs = (input || {}).tapScriptSig;\n    if (!input || !tapSigs || tapSigs.length < 1) {\n      throw new Error('No signatures to validate');\n    }\n    let mySigs;\n    if (pubkey) {\n      mySigs = tapSigs.filter((sig) => equalPublicKeyIgnoreY(sig.pubkey, pubkey));\n      if (mySigs.length < 1) {\n        throw new Error('No signatures for this pubkey');\n      }\n    } else {\n      mySigs = tapSigs;\n    }\n    const results: boolean[] = [];\n\n    assert(input.tapLeafScript?.length === 1, `single tapLeafScript is expected. Got ${input.tapLeafScript?.length}`);\n    const [tapLeafScript] = input.tapLeafScript;\n    const pubKeys = this.isMultisigTaprootScript(tapLeafScript.script)\n      ? parsePubScript2Of3(tapLeafScript.script, 'taprootScriptPathSpend').publicKeys\n      : undefined;\n\n    for (const pSig of mySigs) {\n      const { signature, leafHash, pubkey } = pSig;\n      if (pubKeys) {\n        assert(\n          pubKeys.find((pk) => pubkey.equals(pk)),\n          'public key not found in tap leaf script'\n        );\n      }\n      let sigHashType: number;\n      let sig: Buffer;\n      if (signature.length === 65) {\n        sigHashType = signature[64];\n        sig = signature.slice(0, 64);\n      } else {\n        sigHashType = Transaction.SIGHASH_DEFAULT;\n        sig = signature;\n      }\n      const { hash } = this.getTaprootHashForSig(inputIndex, [sigHashType], leafHash);\n      results.push(eccLib.verifySchnorr(hash, pubkey, sig));\n    }\n    return results.every((res) => res);\n  }\n\n  /**\n   * @param inputIndex\n   * @param rootNodes optional input root bip32 nodes to verify with. If it is not provided, globalXpub will be used.\n   * @return array of boolean values. True when corresponding index in `publicKeys` has signed the transaction.\n   * If no signature in the tx or no public key matching signature, the validation is considered as false.\n   * If rootNodes are not explicitly passed in, the return array will be unordered.\n   * Use getSortedRootNodes() instead if ordering is important.\n   */\n  getSignatureValidationArray(\n    inputIndex: number,\n    { rootNodes }: { rootNodes: Triple<BIP32Interface> | undefined }\n  ): Triple<boolean> {\n    if (!rootNodes && (!this.data.globalMap.globalXpub?.length || !isTriple(this.data.globalMap.globalXpub))) {\n      throw new Error('Cannot get signature validation array without 3 global xpubs');\n    }\n\n    const bip32s = rootNodes\n      ? rootNodes\n      : this.data.globalMap.globalXpub?.map((xpub) =>\n          BIP32Factory(eccLib).fromBase58(bs58check.encode(xpub.extendedPubkey))\n        );\n\n    if (!bip32s) {\n      throw new Error('either globalMap or rootNodes is required');\n    }\n\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (!getPsbtInputSignatureCount(input)) {\n      return [false, false, false];\n    }\n\n    return bip32s.map((bip32) => {\n      const pubKey = UtxoPsbt.deriveKeyPairForInput(bip32, input);\n      if (!pubKey) {\n        return false;\n      }\n      try {\n        return this.validateSignaturesOfInputCommon(inputIndex, pubKey);\n      } catch (err) {\n        // Not an elegant solution. Might need upstream changes like custom error types.\n        if (err.message === 'No signatures for this pubkey') {\n          return false;\n        }\n        throw err;\n      }\n    }) as Triple<boolean>;\n  }\n\n  /**\n   * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts\n   */\n  signAllInputsHD(\n    hdKeyPair: HDTaprootSigner | HDTaprootMusig2Signer,\n    params?: number[] | Partial<SignatureParams>\n  ): this {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const { sighashTypes, deterministic } = toSignatureParams(this.network, params);\n\n    const results: boolean[] = [];\n    for (let i = 0; i < this.data.inputs.length; i++) {\n      try {\n        this.signInputHD(i, hdKeyPair, { sighashTypes, deterministic });\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every((v) => !v)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n\n  /**\n   * Mostly copied from bitcoinjs-lib/ts_src/psbt.ts:signInputHD\n   */\n  signTaprootInputHD(\n    inputIndex: number,\n    hdKeyPair: HDTaprootSigner | HDTaprootMusig2Signer,\n    { sighashTypes = [Transaction.SIGHASH_DEFAULT, Transaction.SIGHASH_ALL], deterministic = false } = {}\n  ): this {\n    if (!this.isTaprootInput(inputIndex)) {\n      throw new Error('not a taproot input');\n    }\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (!input.tapBip32Derivation || input.tapBip32Derivation.length === 0) {\n      throw new Error('Need tapBip32Derivation to sign Taproot with HD');\n    }\n    const myDerivations = input.tapBip32Derivation\n      .map((bipDv) => {\n        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n          return bipDv;\n        }\n      })\n      .filter((v) => !!v) as TapBip32Derivation[];\n    if (myDerivations.length === 0) {\n      throw new Error('Need one tapBip32Derivation masterFingerprint to match the HDSigner fingerprint');\n    }\n\n    function getDerivedNode(bipDv: TapBip32Derivation): HDTaprootMusig2Signer | HDTaprootSigner {\n      const node = hdKeyPair.derivePath(bipDv.path);\n      if (!equalPublicKeyIgnoreY(bipDv.pubkey, node.publicKey)) {\n        throw new Error('pubkey did not match tapBip32Derivation');\n      }\n      return node;\n    }\n\n    if (input.tapLeafScript?.length) {\n      const signers: TaprootSigner[] = myDerivations.map((bipDv) => {\n        const signer = getDerivedNode(bipDv);\n        if (!('signSchnorr' in signer)) {\n          throw new Error('signSchnorr function is required to sign p2tr');\n        }\n        return { signer, leafHashes: bipDv.leafHashes };\n      });\n      signers.forEach(({ signer, leafHashes }) => this.signTaprootInput(inputIndex, signer, leafHashes, sighashTypes));\n    } else if (input.tapInternalKey?.length) {\n      const signers: Musig2Signer[] = myDerivations.map((bipDv) => {\n        const signer = getDerivedNode(bipDv);\n        if (!('privateKey' in signer) || !signer.privateKey) {\n          throw new Error('privateKey is required to sign p2tr musig2');\n        }\n        return signer;\n      });\n      signers.forEach((signer) => this.signTaprootMusig2Input(inputIndex, signer, { sighashTypes, deterministic }));\n    }\n    return this;\n  }\n\n  signInput(inputIndex: number, keyPair: Signer, sighashTypes?: number[]): this {\n    const { sighashTypes: sighashForNetwork } = toSignatureParams(this.network, sighashTypes);\n    return super.signInput(inputIndex, keyPair, sighashForNetwork);\n  }\n\n  signInputHD(\n    inputIndex: number,\n    hdKeyPair: HDTaprootSigner | HDTaprootMusig2Signer,\n    params?: number[] | Partial<SignatureParams>\n  ): this {\n    const { sighashTypes, deterministic } = toSignatureParams(this.network, params);\n    if (this.isTaprootInput(inputIndex)) {\n      return this.signTaprootInputHD(inputIndex, hdKeyPair, { sighashTypes, deterministic });\n    } else {\n      return super.signInputHD(inputIndex, hdKeyPair, sighashTypes);\n    }\n  }\n\n  private getMusig2Participants(inputIndex: number, tapInternalKey: Buffer, tapMerkleRoot: Buffer) {\n    const participantsKeyValData = parsePsbtMusig2Participants(this.data.inputs[inputIndex]);\n    if (!participantsKeyValData) {\n      throw new Error(`Found 0 matching participant key value instead of 1`);\n    }\n    assertPsbtMusig2Participants(participantsKeyValData, tapInternalKey, tapMerkleRoot);\n    return participantsKeyValData;\n  }\n\n  private getMusig2Nonces(inputIndex: number, participantsKeyValData: PsbtMusig2Participants) {\n    const noncesKeyValsData = parsePsbtMusig2Nonces(this.data.inputs[inputIndex]);\n    if (!noncesKeyValsData || !isTuple(noncesKeyValsData)) {\n      throw new Error(\n        `Found ${noncesKeyValsData?.length ? noncesKeyValsData.length : 0} matching nonce key value instead of 2`\n      );\n    }\n    assertPsbtMusig2Nonces(noncesKeyValsData, participantsKeyValData);\n    return noncesKeyValsData;\n  }\n\n  /**\n   * Signs p2tr musig2 key path input with 2 aggregated keys.\n   *\n   * Note: Only can sign deterministically as the cosigner\n   * @param inputIndex\n   * @param signer - XY public key and private key are required\n   * @param sighashTypes\n   * @param deterministic If true, sign the musig input deterministically\n   */\n  signTaprootMusig2Input(\n    inputIndex: number,\n    signer: Musig2Signer,\n    { sighashTypes = [Transaction.SIGHASH_DEFAULT, Transaction.SIGHASH_ALL], deterministic = false } = {}\n  ): this {\n    if (!this.isTaprootKeyPathInput(inputIndex)) {\n      throw new Error('not a taproot musig2 input');\n    }\n\n    const input = this.data.inputs[inputIndex];\n\n    if (!input.tapInternalKey || !input.tapMerkleRoot) {\n      throw new Error('missing required input data');\n    }\n\n    // Retrieve and check that we have two participant nonces\n    const participants = this.getMusig2Participants(inputIndex, input.tapInternalKey, input.tapMerkleRoot);\n    const { tapOutputKey, participantPubKeys } = participants;\n    const signerPubKey = participantPubKeys.find((pubKey) => equalPublicKeyIgnoreY(pubKey, signer.publicKey));\n    if (!signerPubKey) {\n      throw new Error('signer pub key should match one of participant pub keys');\n    }\n\n    const nonces = this.getMusig2Nonces(inputIndex, participants);\n    const { hash, sighashType } = this.getTaprootHashForSig(inputIndex, sighashTypes);\n\n    let partialSig: Buffer;\n    if (deterministic) {\n      if (!equalPublicKeyIgnoreY(signerPubKey, participantPubKeys[1])) {\n        throw new Error('can only add a deterministic signature on the cosigner');\n      }\n\n      const firstSignerNonce = nonces.find((n) => equalPublicKeyIgnoreY(n.participantPubKey, participantPubKeys[0]));\n      if (!firstSignerNonce) {\n        throw new Error('could not find the user nonce');\n      }\n\n      partialSig = musig2DeterministicSign({\n        privateKey: signer.privateKey,\n        otherNonce: firstSignerNonce.pubNonce,\n        publicKeys: participantPubKeys,\n        internalPubKey: input.tapInternalKey,\n        tapTreeRoot: input.tapMerkleRoot,\n        hash,\n      }).sig;\n    } else {\n      const sessionKey = createMusig2SigningSession({\n        pubNonces: [nonces[0].pubNonce, nonces[1].pubNonce],\n        pubKeys: participantPubKeys,\n        txHash: hash,\n        internalPubKey: input.tapInternalKey,\n        tapTreeRoot: input.tapMerkleRoot,\n      });\n\n      const signerNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, signerPubKey));\n      if (!signerNonce) {\n        throw new Error('pubNonce is missing. retry signing process');\n      }\n      partialSig = musig2PartialSign(signer.privateKey, signerNonce.pubNonce, sessionKey, this.nonceStore);\n    }\n\n    if (sighashType !== Transaction.SIGHASH_DEFAULT) {\n      partialSig = Buffer.concat([partialSig, Buffer.of(sighashType)]);\n    }\n\n    const sig = encodePsbtMusig2PartialSig({\n      participantPubKey: signerPubKey,\n      tapOutputKey,\n      partialSig: partialSig,\n    });\n    this.addProprietaryKeyValToInput(inputIndex, sig);\n    return this;\n  }\n\n  signTaprootInput(\n    inputIndex: number,\n    signer: SchnorrSigner,\n    leafHashes: Buffer[],\n    sighashTypes: number[] = [Transaction.SIGHASH_DEFAULT, Transaction.SIGHASH_ALL]\n  ): this {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    // Figure out if this is script path or not, if not, tweak the private key\n    if (!input.tapLeafScript?.length) {\n      throw new Error('tapLeafScript is required for p2tr script path');\n    }\n    const pubkey = toXOnlyPublicKey(signer.publicKey);\n    if (input.tapLeafScript.length !== 1) {\n      throw new Error('Only one leaf script supported for signing');\n    }\n    const [tapLeafScript] = input.tapLeafScript;\n\n    if (this.isMultisigTaprootScript(tapLeafScript.script)) {\n      const pubKeys = parsePubScript2Of3(tapLeafScript.script, 'taprootScriptPathSpend').publicKeys;\n      assert(\n        pubKeys.find((pk) => pubkey.equals(pk)),\n        'public key not found in tap leaf script'\n      );\n    }\n\n    const parsedControlBlock = taproot.parseControlBlock(eccLib, tapLeafScript.controlBlock);\n    const { leafVersion } = parsedControlBlock;\n    if (leafVersion !== tapLeafScript.leafVersion) {\n      throw new Error('Tap script leaf version mismatch with control block');\n    }\n    const leafHash = taproot.getTapleafHash(eccLib, parsedControlBlock, tapLeafScript.script);\n    if (!leafHashes.find((l) => l.equals(leafHash))) {\n      throw new Error(`Signer cannot sign for leaf hash ${leafHash.toString('hex')}`);\n    }\n    const { hash, sighashType } = this.getTaprootHashForSig(inputIndex, sighashTypes, leafHash);\n    let signature = signer.signSchnorr(hash);\n    if (sighashType !== Transaction.SIGHASH_DEFAULT) {\n      signature = Buffer.concat([signature, Buffer.of(sighashType)]);\n    }\n    this.data.updateInput(inputIndex, {\n      tapScriptSig: [\n        {\n          pubkey,\n          signature,\n          leafHash,\n        },\n      ],\n    });\n    return this;\n  }\n\n  private getTaprootOutputScript(inputIndex: number) {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (input.tapLeafScript?.length) {\n      return taproot.createTaprootOutputScript({\n        controlBlock: input.tapLeafScript[0].controlBlock,\n        leafScript: input.tapLeafScript[0].script,\n      });\n    } else if (input.tapInternalKey && input.tapMerkleRoot) {\n      return taproot.createTaprootOutputScript({\n        internalPubKey: input.tapInternalKey,\n        taptreeRoot: input.tapMerkleRoot,\n      });\n    }\n    throw new Error('not a taproot input');\n  }\n\n  private getTaprootHashForSig(\n    inputIndex: number,\n    sighashTypes?: number[],\n    leafHash?: Buffer\n  ): {\n    hash: Buffer;\n    sighashType: number;\n  } {\n    if (!this.isTaprootInput(inputIndex)) {\n      throw new Error('not a taproot input');\n    }\n    const sighashType = this.data.inputs[inputIndex].sighashType || Transaction.SIGHASH_DEFAULT;\n    if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n      throw new Error(\n        `Sighash type is not allowed. Retry the sign method passing the ` +\n          `sighashTypes array of whitelisted types. Sighash type: ${sighashType}`\n      );\n    }\n    const txInputs = this.txInputs; // These are somewhat costly to extract\n    const prevoutScripts: Buffer[] = [];\n    const prevoutValues: bigint[] = [];\n\n    this.data.inputs.forEach((input, i) => {\n      let prevout;\n      if (input.nonWitnessUtxo) {\n        // TODO: This could be costly, either cache it here, or find a way to share with super\n        const nonWitnessUtxoTx = (this.constructor as typeof UtxoPsbt).transactionFromBuffer(\n          input.nonWitnessUtxo,\n          this.tx.network\n        );\n\n        const prevoutHash = txInputs[i].hash;\n        const utxoHash = nonWitnessUtxoTx.getHash();\n\n        // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n        if (!prevoutHash.equals(utxoHash)) {\n          throw new Error(`Non-witness UTXO hash for input #${i} doesn't match the hash specified in the prevout`);\n        }\n\n        const prevoutIndex = txInputs[i].index;\n        prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n      } else if (input.witnessUtxo) {\n        prevout = input.witnessUtxo;\n      } else {\n        throw new Error('Need a Utxo input item for signing');\n      }\n      prevoutScripts.push(prevout.script);\n      prevoutValues.push(prevout.value);\n    });\n    const outputScript = this.getTaprootOutputScript(inputIndex);\n    if (!outputScript.equals(prevoutScripts[inputIndex])) {\n      throw new Error(`Witness script for input #${inputIndex} doesn't match the scriptPubKey in the prevout`);\n    }\n    const hash = this.tx.hashForWitnessV1(inputIndex, prevoutScripts, prevoutValues, sighashType, leafHash);\n    return { hash, sighashType };\n  }\n\n  /**\n   * Adds proprietary key value pair to PSBT input.\n   * Default identifierEncoding is utf-8 for identifier.\n   */\n  addProprietaryKeyValToInput(inputIndex: number, keyValueData: ProprietaryKeyValue): this {\n    return this.addUnknownKeyValToInput(inputIndex, {\n      key: encodeProprietaryKey(keyValueData.key),\n      value: keyValueData.value,\n    });\n  }\n\n  /**\n   * Adds or updates (if exists) proprietary key value pair to PSBT input.\n   * Default identifierEncoding is utf-8 for identifier.\n   */\n  addOrUpdateProprietaryKeyValToInput(inputIndex: number, keyValueData: ProprietaryKeyValue): this {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    const key = encodeProprietaryKey(keyValueData.key);\n    const { value } = keyValueData;\n    if (input.unknownKeyVals?.length) {\n      const ukvIndex = input.unknownKeyVals.findIndex((ukv) => ukv.key.equals(key));\n      if (ukvIndex > -1) {\n        input.unknownKeyVals[ukvIndex] = { key, value };\n        return this;\n      }\n    }\n    this.addUnknownKeyValToInput(inputIndex, {\n      key,\n      value,\n    });\n    return this;\n  }\n\n  /**\n   * To search any data from proprietary key value against keydata.\n   * Default identifierEncoding is utf-8 for identifier.\n   */\n  getProprietaryKeyVals(inputIndex: number, keySearch?: ProprietaryKeySearch): ProprietaryKeyValue[] {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    return getPsbtInputProprietaryKeyVals(input, keySearch);\n  }\n\n  /**\n   * To delete any data from proprietary key value.\n   * Default identifierEncoding is utf-8 for identifier.\n   */\n  deleteProprietaryKeyVals(inputIndex: number, keysToDelete?: ProprietaryKeySearch): this {\n    const input = checkForInput(this.data.inputs, inputIndex);\n    if (!input.unknownKeyVals?.length) {\n      return this;\n    }\n    if (keysToDelete && keysToDelete.subtype === undefined && Buffer.isBuffer(keysToDelete.keydata)) {\n      throw new Error('invalid proprietary key search filter combination. subtype is required');\n    }\n    input.unknownKeyVals = input.unknownKeyVals.filter((keyValue, i) => {\n      const key = decodeProprietaryKey(keyValue.key);\n      return !(\n        keysToDelete === undefined ||\n        (keysToDelete.identifier === key.identifier &&\n          (keysToDelete.subtype === undefined ||\n            (keysToDelete.subtype === key.subtype &&\n              (!Buffer.isBuffer(keysToDelete.keydata) || keysToDelete.keydata.equals(key.keydata)))))\n      );\n    });\n    return this;\n  }\n\n  private createMusig2NonceForInput(\n    inputIndex: number,\n    keyPair: BIP32Interface,\n    keyType: 'root' | 'derived',\n    params: { sessionId?: Buffer; deterministic?: boolean } = { deterministic: false }\n  ): PsbtMusig2PubNonce {\n    const input = this.data.inputs[inputIndex];\n    if (!input.tapInternalKey) {\n      throw new Error('tapInternalKey is required to create nonce');\n    }\n    if (!input.tapMerkleRoot) {\n      throw new Error('tapMerkleRoot is required to create nonce');\n    }\n    const getDerivedKeyPair = (): BIP32Interface => {\n      if (!input.tapBip32Derivation?.length) {\n        throw new Error('tapBip32Derivation is required to create nonce');\n      }\n      const derived = UtxoPsbt.deriveKeyPair(keyPair, input.tapBip32Derivation, { ignoreY: true });\n      if (!derived) {\n        throw new Error('No bip32Derivation masterFingerprint matched the HD keyPair fingerprint');\n      }\n      return derived;\n    };\n    const derivedKeyPair = keyType === 'root' ? getDerivedKeyPair() : keyPair;\n    if (!derivedKeyPair.privateKey) {\n      throw new Error('privateKey is required to create nonce');\n    }\n    const participants = parsePsbtMusig2Participants(input);\n    if (!participants) {\n      throw new Error(`Found 0 matching participant key value instead of 1`);\n    }\n    assertPsbtMusig2Participants(participants, input.tapInternalKey, input.tapMerkleRoot);\n    const { tapOutputKey, participantPubKeys } = participants;\n\n    const participantPubKey = participantPubKeys.find((pubKey) =>\n      equalPublicKeyIgnoreY(pubKey, derivedKeyPair.publicKey)\n    );\n    if (!Buffer.isBuffer(participantPubKey)) {\n      throw new Error('participant plain pub key should match one bip32Derivation plain pub key');\n    }\n\n    const { hash } = this.getTaprootHashForSig(inputIndex);\n\n    let pubNonce: Buffer;\n    if (params.deterministic) {\n      if (params.sessionId) {\n        throw new Error('Cannot add extra entropy when generating a deterministic nonce');\n      }\n      // There must be only 2 participant pubKeys if it got to this point\n      if (!equalPublicKeyIgnoreY(participantPubKey, participantPubKeys[1])) {\n        throw new Error(`Only the cosigner's nonce can be set deterministically`);\n      }\n      const nonces = parsePsbtMusig2Nonces(input);\n      if (!nonces) {\n        throw new Error(`No nonces found on input #${inputIndex}`);\n      }\n      if (nonces.length > 2) {\n        throw new Error(`Cannot have more than 2 nonces`);\n      }\n      const firstSignerNonce = nonces.find((kv) => equalPublicKeyIgnoreY(kv.participantPubKey, participantPubKeys[0]));\n      if (!firstSignerNonce) {\n        throw new Error('signer nonce must be set if cosigner nonce is to be derived deterministically');\n      }\n\n      pubNonce = createMusig2DeterministicNonce({\n        privateKey: derivedKeyPair.privateKey,\n        otherNonce: firstSignerNonce.pubNonce,\n        publicKeys: participantPubKeys,\n        internalPubKey: input.tapInternalKey,\n        tapTreeRoot: input.tapMerkleRoot,\n        hash,\n      });\n    } else {\n      pubNonce = Buffer.from(\n        this.nonceStore.createMusig2Nonce(\n          derivedKeyPair.privateKey,\n          participantPubKey,\n          tapOutputKey,\n          hash,\n          params.sessionId\n        )\n      );\n    }\n\n    return { tapOutputKey, participantPubKey, pubNonce };\n  }\n\n  private setMusig2NoncesInner(\n    keyPair: BIP32Interface,\n    keyType: 'root' | 'derived',\n    inputIndex?: number,\n    params: { sessionId?: Buffer; deterministic?: boolean } = { deterministic: false }\n  ): this {\n    if (keyPair.isNeutered()) {\n      throw new Error('private key is required to generate nonce');\n    }\n    if (Buffer.isBuffer(params.sessionId) && params.sessionId.length !== 32) {\n      throw new Error(`Invalid sessionId size ${params.sessionId.length}`);\n    }\n    // @ts-ignore\n    const inputIndexes = inputIndex === undefined ? [...Array(this.inputCount).keys()] : [inputIndex];\n    inputIndexes.forEach((index) => {\n      if (!this.isTaprootKeyPathInput(index)) {\n        return;\n      }\n      const nonce = this.createMusig2NonceForInput(index, keyPair, keyType, params);\n      this.addOrUpdateProprietaryKeyValToInput(index, encodePsbtMusig2PubNonce(nonce));\n    });\n    return this;\n  }\n\n  /**\n   * Generates and sets MuSig2 nonce to taproot key path input at inputIndex.\n   * If input is not a taproot key path, no action.\n   *\n   * @param inputIndex input index\n   * @param keyPair derived key pair\n   * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,\n   * (converted to an array of 32 bytes), or 32 uniformly random bytes.\n   * @param deterministic If true, set the cosigner nonce deterministically\n   */\n  setInputMusig2Nonce(\n    inputIndex: number,\n    derivedKeyPair: BIP32Interface,\n    params: { sessionId?: Buffer; deterministic?: boolean } = { deterministic: false }\n  ): this {\n    return this.setMusig2NoncesInner(derivedKeyPair, 'derived', inputIndex, params);\n  }\n\n  /**\n   * Generates and sets MuSig2 nonce to taproot key path input at inputIndex.\n   * If input is not a taproot key path, no action.\n   *\n   * @param inputIndex input index\n   * @param keyPair HD root key pair\n   * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,\n   * (converted to an array of 32 bytes), or 32 uniformly random bytes.\n   * @param deterministic If true, set the cosigner nonce deterministically\n   */\n  setInputMusig2NonceHD(\n    inputIndex: number,\n    keyPair: BIP32Interface,\n    params: { sessionId?: Buffer; deterministic?: boolean } = { deterministic: false }\n  ): this {\n    checkForInput(this.data.inputs, inputIndex);\n    return this.setMusig2NoncesInner(keyPair, 'root', inputIndex, params);\n  }\n\n  /**\n   * Generates and sets MuSig2 nonce to all taproot key path inputs. Other inputs will be skipped.\n   *\n   * @param inputIndex input index\n   * @param keyPair derived key pair\n   * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,\n   * (converted to an array of 32 bytes), or 32 uniformly random bytes.\n   */\n  setAllInputsMusig2Nonce(\n    keyPair: BIP32Interface,\n    params: { sessionId?: Buffer; deterministic?: boolean } = { deterministic: false }\n  ): this {\n    return this.setMusig2NoncesInner(keyPair, 'derived', undefined, params);\n  }\n\n  /**\n   * Generates and sets MuSig2 nonce to all taproot key path inputs. Other inputs will be skipped.\n   *\n   * @param inputIndex input index\n   * @param keyPair HD root key pair\n   * @param sessionId Optional extra entropy. If provided it must either be a counter unique to this secret key,\n   * (converted to an array of 32 bytes), or 32 uniformly random bytes.\n   */\n  setAllInputsMusig2NonceHD(\n    keyPair: BIP32Interface,\n    params: { sessionId?: Buffer; deterministic?: boolean } = { deterministic: false }\n  ): this {\n    return this.setMusig2NoncesInner(keyPair, 'root', undefined, params);\n  }\n\n  clone(): this {\n    return super.clone() as this;\n  }\n\n  extractTransaction(disableFeeCheck = true): UtxoTransaction<bigint> {\n    const tx = super.extractTransaction(disableFeeCheck);\n    if (tx instanceof UtxoTransaction) {\n      return tx;\n    }\n    throw new Error('extractTransaction did not return instace of UtxoTransaction');\n  }\n}\n"]}
{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/templates/scripthash/input.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/templates/scripthash/input.ts"],"names":[],"mappings":";AAAA,+CAA+C;;AAS/C,sBA6BC;AApCD,8BAA2C;AAC3C,oCAAoC;AACpC,kCAAkC;AAClC,uCAAuC;AACvC,uDAAuD;AACvD,sDAAsD;AAEtD,SAAgB,KAAK,CAAC,MAAuC,EAAE,eAAyB;IACtF,MAAM,MAAM,GAAG,UAAO,CAAC,SAAS,CAAC,MAAM,CAAE,CAAC;IAC1C,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC;QAAE,OAAO,KAAK,CAAC;IAEpC,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC5C,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC;QAAE,OAAO,KAAK,CAAC;IAE9C,MAAM,eAAe,GAAG,UAAO,CAAC,SAAS,CAAC,UAAO,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAE,CAAC;IACjF,MAAM,kBAAkB,GAAG,UAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IAExD,kCAAkC;IAClC,IAAI,CAAC,kBAAkB;QAAE,OAAO,KAAK,CAAC;IAEtC,gCAAgC;IAChC,IAAI,CAAC,UAAO,CAAC,UAAU,CAAC,eAAe,CAAC;QAAE,OAAO,KAAK,CAAC;IAEvD,cAAc;IACd,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QACxB,OAAO,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;IAC/E,CAAC;IAED,cAAc;IACd,IAAI,KAAK,CAAC,KAAK,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC;QAAE,OAAO,IAAI,CAAC;IAE9F,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,eAAe,EAAE,eAAe,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC;QAAE,OAAO,IAAI,CAAC;IAE7G,IAAI,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,eAAe,CAAC,IAAI,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,kBAAkB,CAAC;QAAE,OAAO,IAAI,CAAC;IAE5F,OAAO,KAAK,CAAC;AACf,CAAC;AACD,KAAK,CAAC,MAAM,GAAG,GAAW,EAAE;IAC1B,OAAO,kBAAkB,CAAC;AAC5B,CAAC,CAAC","sourcesContent":["// <scriptSig> {serialized scriptPubKey script}\n\nimport { script as bscript } from '../../';\nimport * as p2ms from '../multisig';\nimport * as p2pk from '../pubkey';\nimport * as p2pkh from '../pubkeyhash';\nimport * as p2wpkho from '../witnesspubkeyhash/output';\nimport * as p2wsho from '../witnessscripthash/output';\n\nexport function check(script: Buffer | Array<number | Buffer>, allowIncomplete?: boolean): boolean {\n  const chunks = bscript.decompile(script)!;\n  if (chunks.length < 1) return false;\n\n  const lastChunk = chunks[chunks.length - 1];\n  if (!Buffer.isBuffer(lastChunk)) return false;\n\n  const scriptSigChunks = bscript.decompile(bscript.compile(chunks.slice(0, -1)))!;\n  const redeemScriptChunks = bscript.decompile(lastChunk);\n\n  // is redeemScript a valid script?\n  if (!redeemScriptChunks) return false;\n\n  // is redeemScriptSig push only?\n  if (!bscript.isPushOnly(scriptSigChunks)) return false;\n\n  // is witness?\n  if (chunks.length === 1) {\n    return p2wsho.check(redeemScriptChunks) || p2wpkho.check(redeemScriptChunks);\n  }\n\n  // match types\n  if (p2pkh.input.check(scriptSigChunks) && p2pkh.output.check(redeemScriptChunks)) return true;\n\n  if (p2ms.input.check(scriptSigChunks, allowIncomplete) && p2ms.output.check(redeemScriptChunks)) return true;\n\n  if (p2pk.input.check(scriptSigChunks) && p2pk.output.check(redeemScriptChunks)) return true;\n\n  return false;\n}\ncheck.toJSON = (): string => {\n  return 'scriptHash input';\n};\n"]}
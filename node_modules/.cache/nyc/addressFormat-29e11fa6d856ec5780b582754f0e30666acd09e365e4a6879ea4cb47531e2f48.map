{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/addressFormat.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/addressFormat.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Implements methods for nonstandard (non-canonical) address formats.\n *\n * Use `toOutputScriptTryFormats()` instead of `toOutputScript()` to parse addresses in\n * non-canonical formats\n */\nimport { getMainnet, getNetworkName, isValidNetwork, Network, networks } from './networks';\nimport { fromOutputScript, toOutputScript } from './address';\n\nimport { bcashAddress } from './bitgo';\n\nexport const addressFormats = ['default', 'cashaddr'] as const;\n\nexport type AddressFormat = (typeof addressFormats)[number];\n\nfunction isCashaddrNetwork(network: Network): boolean {\n  return isValidNetwork(network) && [networks.bitcoincash, networks.ecash].includes(getMainnet(network));\n}\n\n/**\n * @param format\n * @param network\n * @return true iff format is supported for network\n */\nexport function isSupportedAddressFormat(format: AddressFormat, network: Network): boolean {\n  switch (format) {\n    case 'default':\n      return true;\n    case 'cashaddr':\n      return isCashaddrNetwork(network);\n  }\n  throw new Error(`unknown address format ${format}`);\n}\n\n/**\n * @param outputScript\n * @param format\n * @param network\n * @return address formatted using provided AddressFormat\n */\nexport function fromOutputScriptWithFormat(outputScript: Buffer, format: AddressFormat, network: Network): string {\n  if (!isSupportedAddressFormat(format, network)) {\n    throw new Error(`unsupported address format ${format} for network ${getNetworkName(network)}`);\n  }\n\n  return isCashaddrNetwork(network)\n    ? bcashAddress.fromOutputScriptWithFormat(outputScript, format, network)\n    : fromOutputScript(outputScript, network);\n}\n\n/**\n * @param address\n * @param format\n * @param network\n * @return output script parsed with provided AddressFormat\n */\nexport function toOutputScriptWithFormat(address: string, format: AddressFormat, network: Network): Buffer {\n  if (!isSupportedAddressFormat(format, network)) {\n    throw new Error(`unsupported address format ${format} for network ${getNetworkName(network)}`);\n  }\n\n  return isCashaddrNetwork(network)\n    ? bcashAddress.toOutputScriptWithFormat(address, format, network)\n    : toOutputScript(address, network);\n}\n\n/**\n * Attempts to parse address with different address formats, returns first hit.\n * @param address\n * @param network\n * @param formats - defaults to all supported address formats for network\n * @return tuple with [AddressFormat, Buffer] containing format and parsed output script\n */\nexport function toOutputScriptAndFormat(\n  address: string,\n  network: Network,\n  formats?: AddressFormat[]\n): [AddressFormat, Buffer] {\n  if (!formats) {\n    formats = addressFormats.filter((f) => isSupportedAddressFormat(f, network));\n  }\n\n  for (const format of formats) {\n    try {\n      return [format, toOutputScriptWithFormat(address, format, network)];\n    } catch (e) {\n      // try next\n    }\n  }\n\n  throw new Error(`could not parse outputScript [formats=${formats}]`);\n}\n\n/**\n * Same as `toOutputScriptAndFormat`, only returning script\n * @param address - {@see toOutputScriptAndFormat}\n * @param network - {@see toOutputScriptAndFormat}\n * @param formats - {@see toOutputScriptAndFormat}\n * @return parsed output script\n */\nexport function toOutputScriptTryFormats(address: string, network: Network, formats?: AddressFormat[]): Buffer {\n  const [, outputScript] = toOutputScriptAndFormat(address, network, formats);\n  return outputScript;\n}\n\n/**\n * @param address\n * @param network\n * @return address in canonical format\n */\nexport function toCanonicalFormat(address: string, network: Network): string {\n  return fromOutputScript(toOutputScriptTryFormats(address, network), network);\n}\n"]}
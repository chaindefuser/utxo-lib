{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/wallet/Psbt.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/wallet/Psbt.ts"],"names":[],"mappings":";;AA+LA,oCAgBC;AASD,wCAYC;AAKD,wDAyCC;AAyED,wCAuDC;AAOD,8CAMC;AAMD,0DAoBC;AAMD,4DAKC;AAKD,4CAEC;AAKD,wCAGC;AAKD,gFAkBC;AAQD,wCAcC;AAOD,0EAQC;AAMD,kEAyCC;AAMD,wEAgBC;AAUD,gCASC;AAKD,kFAOC;AAnnBD,iCAAiC;AAGjC,gDAAqD;AAErD,uCAAuC;AACvC,0CAAuC;AACvC,wDAAqD;AACrD,oDAM0B;AAC1B,6CAAiE;AACjE,wCAAoD;AACpD,gDAA2G;AAC3G,uCAA2D;AAE3D,8CAeuB;AACvB,sCAAuD;AACvD,oCAA2C;AAC3C,2CAA0D;AAC1D,iDAA2E;AAC3E,uCAAgD;AAChD,0CAA+E;AAqE/E,SAAS,iBAAiB,CAAC,MAAc,EAAE,UAA6B;IACtE,MAAM,gBAAgB,GAAG,IAAA,+BAAkB,EAAC,MAAM,EAAE,wBAAwB,CAAC,CAAC,UAAU,CAAC;IACzF,MAAM,aAAa,GAAG,gBAAgB,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE;QACvD,MAAM,KAAK,GAAG,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,eAAe,EAAE,EAAE,CAChE,IAAA,gCAAgB,EAAC,eAAe,CAAC,CAAC,MAAM,CAAC,SAAS,CAAC,CACpD,CAAC;QACF,IAAI,KAAK,IAAI,CAAC,EAAE,CAAC;YACf,OAAO,EAAE,SAAS,EAAE,UAAU,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,OAAO,EAAE,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC;QAC3F,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;IACnE,CAAC,CAAC,CAAC;IACH,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC;AAC9C,CAAC;AAED,SAAS,eAAe,CACtB,IAAc,EACd,UAAkB,EAClB,OAA8B,EAC9B,cAA8B;IAE9B,MAAM,KAAK,GAAG,IAAA,qBAAa,EAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IAC1D,MAAM,cAAc,GAAG,IAAA,qCAA0B,EAAC,KAAK,CAAC,CAAC;IACzD,MAAM,UAAU,GAAG,IAAA,kCAAkB,EAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACrD,IAAI,cAAc,KAAK,CAAC,IAAI,UAAU,KAAK,MAAM,EAAE,CAAC;QAClD,OAAO;IACT,CAAC;IACD,MAAM,UAAU,GAAG,cAAc,CAAC,sBAAsB,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;IAEvF,IAAI,UAAU,KAAK,MAAM,EAAE,CAAC;QAC1B,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,KAAK,CAAC,aAAa,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YAC5E,MAAM,IAAI,KAAK,CAAC,8CAA8C,CAAC,CAAC;QAClE,CAAC;QAED,IAAI,KAAK,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACnC,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC,CAAC;QAC5E,CAAC;QAED,MAAM,CAAC,MAAM,EAAE,QAAQ,CAAC,GAAG,iBAAiB,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;QAExF,MAAM,QAAQ,GAAG,IAAA,2BAAW,EAAC;YAC3B,UAAU,EAAE,UAAU,CAAC,UAAU;YACjC,MAAM,EAAE,MAAM,CAAC,SAAS,CAAC,SAAS;YAClC,QAAQ,EAAE,QAAQ,CAAC,SAAS,CAAC,SAAS;SACvC,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE;YAC3B,kBAAkB,EAAE,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;gBAC5D,UAAU,EAAE,CAAC,QAAQ,CAAC;gBACtB,MAAM,EAAE,IAAA,gCAAgB,EAAC,YAAY,CAAC,SAAS,CAAC,SAAS,CAAC;gBAC1D,IAAI,EAAE,cAAc,CAAC,iBAAiB,CAAC,YAAY,CAAC,OAAO,EAAE,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,KAAK,CAAC;gBAC1F,iBAAiB,EAAE,YAAY,CAAC,OAAO,CAAC,WAAW;aACpD,CAAC,CAAC;SACJ,CAAC,CAAC;IACL,CAAC;SAAM,CAAC;QACN,IAAI,cAAc,KAAK,CAAC,EAAE,CAAC;YACzB,MAAM,EAAE,aAAa,EAAE,YAAY,EAAE,GAAG,IAAA,sCAAsB,EAAC,UAAU,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;YAClG,IAAI,aAAa,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,aAAa,KAAK,SAAS,EAAE,CAAC;gBAC9E,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,EAAE,aAAa,EAAE,CAAC,CAAC;YAClD,CAAC;YACD,IAAI,YAAY,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC,YAAY,KAAK,SAAS,EAAE,CAAC;gBAC5E,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,EAAE,YAAY,EAAE,CAAC,CAAC;YACjD,CAAC;QACH,CAAC;QAED,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE;YAC3B,eAAe,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;gBACvC,MAAM,EAAE,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,SAAS;gBACxC,IAAI,EAAE,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC;gBAC3B,iBAAiB,EAAE,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,WAAW;aAC1D,CAAC,CAAC;SACJ,CAAC,CAAC;IACL,CAAC;AACH,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,YAAY,CAC1B,EAA2B,EAC3B,QAAiC,EACjC,cAA8B;IAE9B,MAAM,WAAW,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE;QACrC,MAAM,CAAC,cAAc,CAAC,IAAA,kCAAkB,EAAC,CAAC,CAAC,KAAK,CAAC,EAAE,YAAY,CAAC,CAAC;QACjE,OAAO,IAAA,gCAAsB,EAAC,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;IAC/C,CAAC,CAAC,CAAC;IACH,MAAM,IAAI,GAAG,IAAA,uCAAyB,EAAC,EAAE,EAAE,WAAW,CAAC,CAAC;IACxD,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;QACxB,IAAI,IAAA,yBAAe,EAAC,CAAC,CAAC,IAAI,CAAC,CAAC,KAAK,KAAK,SAAS,EAAE,CAAC;YAChD,eAAe,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,cAAc,CAAC,CAAC;QAC9C,CAAC;IACH,CAAC,CAAC,CAAC;IACH,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;;;;GAMG;AACH,SAAgB,cAAc,CAC5B,IAAc,EACd,UAAkB,EAClB,MAAsB,EACtB,OAA8B;IAE9B,MAAM,UAAU,GAAG,IAAA,kCAAkB,EAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IACrD,IAAI,UAAU,KAAK,MAAM,IAAI,UAAU,KAAK,YAAY,EAAE,CAAC;QACzD,IAAI,CAAC,kBAAkB,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IAC9C,CAAC;SAAM,CAAC;QACN,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IACvC,CAAC;AACH,CAAC;AAED;;GAEG;AACH,SAAgB,sBAAsB,CAAC,KAAgB;IACrD,MAAM,MAAM,GAAG,CAAC,MAAc,EAAE,EAAE;QAChC,IAAI,CAAC;YACH,MAAM,MAAM,GAAG,sBAAO,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;YACzC,OAAO,CACL,MAAM,EAAE,MAAM,KAAK,CAAC;gBACpB,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC1B,sBAAO,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBACpC,MAAM,CAAC,CAAC,CAAC,KAAK,eAAO,CAAC,WAAW,CAClC,CAAC;QACJ,CAAC;QAAC,OAAO,CAAC,EAAE,CAAC;YACX,OAAO,KAAK,CAAC;QACf,CAAC;IACH,CAAC,CAAC;IACF,IAAI,UAAwC,CAAC;IAC7C,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,CAAC;QAChF,UAAU,GAAG,WAAW,CAAC;IAC3B,CAAC;SAAM,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC;QAC/C,UAAU,GAAG,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,CAAC,CAAC,MAAM,CAAC;IAChE,CAAC;SAAM,IAAI,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,aAAa,CAAC,EAAE,CAAC;QAChD,UAAU,GAAG,OAAO,CAAC;IACvB,CAAC;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,aAAa,CAAC,IAAI,KAAK,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACzE,IAAI,UAAU,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,cAAc,UAAU,uCAAuC,CAAC,CAAC;QACnF,CAAC;QACD,IAAI,KAAK,CAAC,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACnC,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;QAC7E,CAAC;QACD,UAAU,GAAG,wBAAwB,CAAC;IACxC,CAAC;IACD,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;QACzB,IAAI,UAAU,EAAE,CAAC;YACf,MAAM,IAAI,KAAK,CAAC,cAAc,UAAU,oCAAoC,CAAC,CAAC;QAChF,CAAC;QACD,UAAU,GAAG,qBAAqB,CAAC;IACrC,CAAC;IACD,IAAI,UAAU,EAAE,CAAC;QACf,OAAO,UAAU,CAAC;IACpB,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;AAC3C,CAAC;AAED,SAAS,6BAA6B,CAAC,KAAgB;IACrD,MAAM,WAAW,GAAG,IAAA,mCAA0B,EAAC,KAAK,CAAC,CAAC;IACtD,IAAI,CAAC,WAAW,EAAE,CAAC;QACjB,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,qBAAqB,EAAE,SAAS,EAAE,CAAC;IACrE,CAAC;IACD,MAAM,UAAU,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC9D,MAAM,qBAAqB,GAAG,WAAW,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,iBAAiB,CAAC,CAAC;IAChF,OAAO,IAAA,eAAO,EAAS,UAAU,CAAC,IAAI,IAAA,eAAO,EAAS,qBAAqB,CAAC;QAC1E,CAAC,CAAC,EAAE,UAAU,EAAE,qBAAqB,EAAE;QACvC,CAAC,CAAC,EAAE,UAAU,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,qBAAqB,EAAE,CAAC,qBAAqB,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AACzF,CAAC;AAED,SAAS,iCAAiC,CAAC,GAA8C;IACvF,IAAI,CAAC,GAAG,EAAE,MAAM,EAAE,CAAC;QACjB,OAAO,EAAE,UAAU,EAAE,SAAS,EAAE,CAAC;IACnC,CAAC;IACD,IAAI,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACnB,MAAM,IAAI,KAAK,CAAC,4BAA4B,CAAC,CAAC;IAChD,CAAC;IACD,MAAM,UAAU,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACrD,OAAO,IAAA,eAAO,EAAS,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,CAAC,CAAC,CAAC,EAAE,UAAU,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC;AACxF,CAAC;AAED,SAAS,eAAe,CACtB,KAAgB,EAChB,UAA4B;IAE5B,OAAO,UAAU,KAAK,qBAAqB;QACzC,CAAC,CAAC,6BAA6B,CAAC,KAAK,CAAC;QACtC,CAAC,CAAC,UAAU,KAAK,wBAAwB;YACzC,CAAC,CAAC,iCAAiC,CAAC,KAAK,CAAC,YAAY,CAAC;YACvD,CAAC,CAAC,iCAAiC,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;AAC1D,CAAC;AAED,SAAS,WAAW,CAClB,KAAgB,EAChB,UAA4B;IAE5B,IAAI,SAA6B,CAAC;IAClC,IAAI,UAAU,KAAK,MAAM,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;QACvD,SAAS,GAAG,KAAK,CAAC,YAAY,CAAC;IACjC,CAAC;SAAM,IAAI,UAAU,KAAK,OAAO,IAAI,UAAU,KAAK,WAAW,EAAE,CAAC;QAChE,SAAS,GAAG,KAAK,CAAC,aAAa,CAAC;IAClC,CAAC;SAAM,IAAI,UAAU,KAAK,wBAAwB,EAAE,CAAC;QACnD,SAAS,GAAG,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC;IAC9E,CAAC;SAAM,IAAI,UAAU,KAAK,qBAAqB,EAAE,CAAC;QAChD,IAAI,KAAK,CAAC,WAAW,EAAE,MAAM,EAAE,CAAC;YAC9B,SAAS,GAAG,KAAK,CAAC,WAAW,CAAC,MAAM,CAAC;QACvC,CAAC;aAAM,IAAI,KAAK,CAAC,cAAc,IAAI,KAAK,CAAC,aAAa,EAAE,CAAC;YACvD,SAAS,GAAG,IAAA,mCAAyB,EAAC,EAAE,cAAc,EAAE,KAAK,CAAC,cAAc,EAAE,WAAW,EAAE,KAAK,CAAC,aAAa,EAAE,CAAC,CAAC;QACpH,CAAC;IACH,CAAC;IACD,IAAI,CAAC,SAAS,EAAE,CAAC;QACf,MAAM,IAAI,KAAK,CAAC,0BAA0B,UAAU,4BAA4B,CAAC,CAAC;IACpF,CAAC;IACD,OAAO,IAAA,2BAAc,EAAC,SAAS,EAAE,UAAU,CAAC,CAAC;AAC/C,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,SAAgB,cAAc,CAAC,KAAgB;IAC7C,IAAI,IAAA,+BAAoB,EAAC,KAAK,CAAC,EAAE,CAAC;QAChC,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC;IAC7D,CAAC;IACD,MAAM,UAAU,GAAG,sBAAsB,CAAC,KAAK,CAAC,CAAC;IACjD,MAAM,eAAe,GAAG,WAAW,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;IACvD,MAAM,UAAU,GAAG,eAAe,CAAC,KAAK,EAAE,UAAU,CAAC,CAAC;IAEtD,IAAI,eAAe,CAAC,UAAU,KAAK,qBAAqB,IAAI,uBAAuB,IAAI,UAAU,EAAE,CAAC;QAClG,OAAO;YACL,GAAG,eAAe;YAClB,GAAG,UAAU;YACb,UAAU,EAAE,eAAe,CAAC,UAAU;SACvC,CAAC;IACJ,CAAC;IACD,IAAI,eAAe,CAAC,UAAU,KAAK,wBAAwB,EAAE,CAAC;QAC5D,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE,CAAC;YACzB,MAAM,IAAI,KAAK,CAAC,yEAAyE,CAAC,CAAC;QAC7F,CAAC;QACD,MAAM,YAAY,GAAG,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,YAAY,CAAC;QACzD,IAAI,CAAC,IAAA,+BAAkB,EAAC,YAAY,CAAC,EAAE,CAAC;YACtC,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;QACvE,CAAC;QACD,MAAM,eAAe,GAAG,IAAA,qCAAwB,EAAC,YAAY,CAAC,CAAC;QAC/D,MAAM,WAAW,GAAG,IAAA,2BAAc,EAAC,YAAY,CAAC,CAAC;QACjD,OAAO;YACL,GAAG,eAAe;YAClB,GAAG,UAAU;YACb,UAAU,EAAE,eAAe,CAAC,UAAU;YACtC,YAAY;YACZ,eAAe;YACf,WAAW;SACZ,CAAC;IACJ,CAAC;IACD,IACE,eAAe,CAAC,UAAU,KAAK,MAAM;QACrC,eAAe,CAAC,UAAU,KAAK,OAAO;QACtC,eAAe,CAAC,UAAU,KAAK,WAAW,EAC1C,CAAC;QACD,IAAI,eAAe,CAAC,UAAU,KAAK,WAAW,EAAE,CAAC;YAC/C,eAAe,CAAC,YAAY,GAAG,KAAK,CAAC,YAAY,CAAC;QACpD,CAAC;QACD,OAAO;YACL,GAAG,eAAe;YAClB,GAAG,UAAU;SACd,CAAC;IACJ,CAAC;IACD,IAAI,eAAe,CAAC,UAAU,KAAK,UAAU,IAAI,CAAC,CAAC,UAAU,CAAC,UAAU,IAAI,CAAC,IAAA,eAAO,EAAC,UAAU,CAAC,UAAU,CAAC,CAAC,EAAE,CAAC;QAC7G,aAAa;QACb,OAAO;YACL,GAAG,eAAe;YAClB,UAAU,EAAE,UAAU,CAAC,UAAU;SAClC,CAAC;IACJ,CAAC;IACD,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;AACxC,CAAC;AAED;;;;GAIG;AACH,SAAgB,iBAAiB,CAAC,gBAAsC;IACtE,OAAO,gBAAgB,KAAK,wBAAwB;QAClD,CAAC,CAAC,CAAC,YAAY,EAAE,MAAM,CAAC;QACxB,CAAC,CAAC,gBAAgB,KAAK,qBAAqB;YAC5C,CAAC,CAAC,CAAC,YAAY,CAAC;YAChB,CAAC,CAAC,CAAC,gBAAgB,CAAC,CAAC;AACzB,CAAC;AAED;;;GAGG;AACH,SAAgB,uBAAuB,CAAC,KAA0B;IAChE,MAAM,uBAAuB,GAAG,CAC9B,UAA0F,EAC/E,EAAE;QACb,MAAM,KAAK,GAAG,UAAU,CAAC,CAAC,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,IAAA,mCAAsB,EAAC,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3F,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,EAAE,CAAC;YAC9C,OAAO,KAAK,CAAC;QACf,CAAC;QACD,MAAM,IAAI,KAAK,CAAC,yBAAyB,CAAC,CAAC;IAC7C,CAAC,CAAC;IAEF,IAAI,MAAM,IAAI,KAAK,EAAE,CAAC;QACpB,IAAI,KAAK,CAAC,MAAM,EAAE,MAAM,IAAI,KAAK,CAAC,OAAO,EAAE,MAAM,EAAE,CAAC;YAClD,MAAM,WAAW,GAAG,IAAA,iCAAoB,EAAC,KAAK,CAAC,CAAC;YAChD,OAAO,WAAW,CAAC,UAAU,KAAK,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,uBAAuB,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAChH,CAAC;QACD,OAAO,CAAC,CAAC;IACX,CAAC;SAAM,CAAC;QACN,OAAO,uBAAuB,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,UAAU,CAAC,CAAC;IACnE,CAAC;AACH,CAAC;AAED;;;GAGG;AACH,SAAgB,wBAAwB,CACtC,EAAyE;IAEzE,MAAM,MAAM,GAAG,EAAE,YAAY,mBAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,YAAY,iCAAe,CAAC,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;IACrG,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,uBAAuB,CAAC,KAAK,CAAC,CAAC,CAAC;AAClE,CAAC;AAED;;KAEK;AACL,SAAgB,gBAAgB,CAAC,MAA+B;IAC9D,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;AACjC,CAAC;AAED;;KAEK;AACL,SAAgB,cAAc,CAAC,MAA+B;IAC5D,MAAM,CAAC,CAAC,CAAC,MAAM,CAAC,MAAM,EAAE,oBAAoB,CAAC,CAAC;IAC9C,OAAO,MAAM,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC;AAC7B,CAAC;AAED;;GAEG;AACH,SAAgB,kCAAkC,CAChD,IAA2E;IAE3E,MAAM,MAAM,GAAG,IAAI,YAAY,mBAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,YAAY,iCAAe,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC;IAC/G,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC;QACnB,OAAO,KAAK,CAAC;IACf,CAAC;IACD,IAAI,gBAAgB,CAAC,MAAM,CAAC,EAAE,CAAC;QAC7B,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE,CAAC,sBAAsB,CAAC,KAAK,CAAC,KAAK,qBAAqB,CAAC,CAAC;IAC5F,CAAC;IACD,OAAO,MAAM,CAAC,IAAI,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QAC9B,4FAA4F;QAC5F,kFAAkF;QAClF,IAAI,uBAAuB,CAAC,KAAK,CAAC,KAAK,CAAC,EAAE,CAAC;YACzC,OAAO,KAAK,CAAC;QACf,CAAC;QACD,OAAO,IAAA,iCAAoB,EAAC,KAAK,CAAC,CAAC,UAAU,KAAK,qBAAqB,CAAC;IAC1E,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;;;GAKG;AACH,SAAgB,cAAc,CAAC,IAAc,EAAE,cAA8B;IAC3E,MAAM,kBAAkB,GAAG,IAAI,2BAAc,CAC3C,cAAc,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,QAAQ,EAAE,CAA2B,EAChF,cAAc,CAAC,kBAAkB,CAClC,CAAC;IACF,MAAM,KAAK,GAAG,kBAAkB,CAAC,MAAM,CAAC,GAAG,CACzC,CAAC,KAAK,EAAc,EAAE,CAAC,CAAC;QACtB,cAAc,EAAE,SAAS,CAAC,MAAM,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAC;QAClD,iBAAiB,EAAE,KAAK,CAAC,WAAW;QACpC,wFAAwF;QACxF,IAAI,EAAE,GAAG;KACV,CAAC,CACH,CAAC;IACF,IAAI,CAAC,YAAY,CAAC,EAAE,UAAU,EAAE,KAAK,EAAE,CAAC,CAAC;AAC3C,CAAC;AAED;;;;GAIG;AACH,SAAgB,+BAA+B,CAAC,IAAc,EAAE,cAA8B;IAC5F,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QACvC,MAAM,mBAAmB,GACvB,sBAAsB,CAAC,KAAK,CAAC,KAAK,UAAU;YAC1C,CAAC,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,KAAK,CAAC;YACvB,CAAC,CAAC,IAAI,CAAC,2BAA2B,CAAC,CAAC,EAAE,EAAE,SAAS,EAAE,cAAc,CAAC,MAAM,EAAE,CAAC,CAAC;QAChF,OAAO,CAAC,CAAC,EAAE,mBAAmB,CAAC,CAAC;IAClC,CAAC,CAAC,CAAC;AACL,CAAC;AAED;;;GAGG;AACH,SAAgB,2BAA2B,CAAC,IAAc;IACxD,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,yBAAyB,CAAC,CAAC;IAC3F,MAAM,EAAE,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;IAEhC,SAAS,qBAAqB,CAC5B,MAA+D;QAE/D,OAAO,CAAC,MAAM,EAAE,WAAW,EAAE,OAAO,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;IACpE,CAAC;IAED,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QACpC,MAAM,MAAM,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACrC,MAAM,CAAC,qBAAqB,CAAC,MAAM,CAAC,EAAE,2BAA2B,MAAM,CAAC,UAAU,EAAE,CAAC,CAAC;QACtF,MAAM,CAAC,KAAK,CAAC,UAAU,EAAE,MAAM,KAAK,CAAC,EAAE,8BAA8B,KAAK,CAAC,UAAU,EAAE,MAAM,EAAE,CAAC,CAAC;QACjG,MAAM,CAAC,UAAU,CAAC,GAAG,KAAK,CAAC,UAAU,CAAC;QACtC,MAAM,CACJ,KAAK,CAAC,WAAW,KAAK,SAAS,IAAI,KAAK,CAAC,WAAW,KAAK,sBAAO,CAAC,SAAS,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,QAAQ,EAChH,qDAAqD,CACtD,CAAC;QAEF,wEAAwE;QACxE,MAAM,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAC9C,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC,CAAE,uBAAG,CAAC,IAA0B,CACtF,CAAC;QAEF,MAAM,MAAM,GAAG,CAAC,CAAC,MAAM,CAAC,YAAY,CAAC;QACrC,MAAM,OAAO,GAAG,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;QAEvC,MAAM,OAAO,GAAG,gBAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,MAAM,CAAC,SAAS,EAAE,UAAU,EAAE,EAAE,EAAE,QAAQ,EAAE,KAAK,EAAE,eAAe,EAAE,IAAI,EAAE,CAAC,CAAC;QACpH,MAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,gBAAQ,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QACxE,MAAM,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,gBAAQ,CAAC,IAAI,CAAC,EAAE,MAAM,EAAE,KAAK,IAAI,OAAO,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;QAE9E,IAAI,IAAI,EAAE,KAAK,EAAE,CAAC;YAChB,EAAE,CAAC,cAAc,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC;QACnC,CAAC;QACD,IAAI,KAAK,EAAE,OAAO,EAAE,CAAC;YACnB,EAAE,CAAC,UAAU,CAAC,CAAC,EAAE,KAAK,CAAC,OAAO,CAAC,CAAC;QAClC,CAAC;IACH,CAAC,CAAC,CAAC;IAEH,OAAO,EAAE,CAAC;AACZ,CAAC;AAED;;;GAGG;AACH,SAAgB,8BAA8B,CAAC,IAAc;IAC3D,MAAM,OAAO,GAAG,IAAA,+BAAiB,EAAC,IAAI,CAAC,KAAK,EAAE,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;IAC9D,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC;IAE/B,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QACpC,IAAI,KAAK,CAAC,cAAc,IAAI,CAAC,KAAK,CAAC,WAAW,EAAE,CAAC;YAC/C,MAAM,EAAE,GAAG,IAAA,yCAA2B,EAAC,KAAK,CAAC,cAAc,EAAE,IAAI,CAAC,OAAO,EAAE,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC,CAAC;YACrG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,EAAE,CAAC;gBAC3C,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,kDAAkD,CAAC,CAAC;YAC3G,CAAC;YACD,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,GAAG,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;QAClE,CAAC;QACD,OAAO,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC;IAC/C,CAAC,CAAC,CAAC;IAEH,OAAO,OAAO,CAAC;AACjB,CAAC;AAED;;;;;;;GAOG;AACH,SAAgB,UAAU,CAAC,IAAc;IACvC,IAAI,MAAM,GAAG,IAAI,CAAC;IAClB,MAAM,mBAAmB,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;IACjD,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE;QACjC,IAAI,MAAM,IAAI,mBAAmB,CAAC,QAAQ,CAAC,sBAAsB,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;YAC1E,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,cAAc,CAAC;QAClC,CAAC;IACH,CAAC,CAAC,CAAC;IACH,OAAO,CAAC,MAAM,CAAC;AACjB,CAAC;AAED;;GAEG;AACH,SAAgB,mCAAmC,CAAC,IAAc;IAChE,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC,EAAE,EAAE;QACpC,MAAM,UAAU,GAAG,sBAAsB,CAAC,KAAK,CAAC,CAAC;QACjD,IAAI,UAAU,KAAK,MAAM,IAAI,UAAU,KAAK,UAAU,EAAE,CAAC;YACvD,OAAO,KAAK,CAAC,WAAW,CAAC;QAC3B,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC","sourcesContent":["import * as assert from 'assert';\n\nimport { GlobalXpub, PartialSig, PsbtInput, TapScriptSig } from 'bip174/src/lib/interfaces';\nimport { checkForInput } from 'bip174/src/lib/utils';\nimport { BIP32Interface } from 'bip32';\nimport * as bs58check from 'bs58check';\nimport { UtxoPsbt } from '../UtxoPsbt';\nimport { UtxoTransaction } from '../UtxoTransaction';\nimport {\n  createOutputScript2of3,\n  getLeafHash,\n  ScriptType2Of3,\n  scriptTypeForChain,\n  toXOnlyPublicKey,\n} from '../outputScripts';\nimport { DerivedWalletKeys, RootWalletKeys } from './WalletKeys';\nimport { toPrevOutputWithPrevTx } from '../Unspent';\nimport { createPsbtFromHex, createPsbtFromTransaction, createTransactionFromBuffer } from '../transaction';\nimport { isWalletUnspent, WalletUnspent } from './Unspent';\n\nimport {\n  getLeafVersion,\n  calculateScriptPathLevel,\n  isValidControlBock,\n  ParsedPubScriptP2ms,\n  ParsedPubScriptTaprootScriptPath,\n  parsePubScript2Of3,\n  ParsedPubScriptTaproot,\n  ParsedPubScriptTaprootKeyPath,\n  parsePubScript,\n  ParsedPubScriptP2shP2pk,\n  ParsedScriptType,\n  isPlaceholderSignature,\n  parseSignatureScript,\n  ParsedScriptType2Of3,\n} from '../parseInput';\nimport { parsePsbtMusig2PartialSigs } from '../Musig2';\nimport { isTuple, Triple } from '../types';\nimport { createTaprootOutputScript } from '../../taproot';\nimport { opcodes as ops, script as bscript, TxInput } from 'bitcoinjs-lib';\nimport { opcodes, payments } from '../../index';\nimport { getPsbtInputSignatureCount, isPsbtInputFinalized } from '../PsbtUtil';\n\n// only used for building `SignatureContainer`\ntype BaseSignatureContainer<T> = {\n  signatures: T;\n};\n\ntype UnsignedSignatureContainer = BaseSignatureContainer<undefined>;\ntype HalfSignedSignatureContainer = BaseSignatureContainer<[Buffer]>;\ntype FullSignedSignatureContainer = BaseSignatureContainer<[Buffer, Buffer]>;\n\ntype SignatureContainer = UnsignedSignatureContainer | HalfSignedSignatureContainer | FullSignedSignatureContainer;\n\n/**\n * Contents of a pre-finalized PSBT Input for p2trMusig2 key path in the non-finalized state.\n * T is [Buffer] for first signature, [Buffer, Buffer] for both signatures and `undefined` for no signatures.\n */\ntype BaseTaprootKeyPathSignatureContainer<T> = {\n  signatures: T;\n  /** Only contains participants that have added a signature */\n  participantPublicKeys: T;\n};\n\ntype UnsignedTaprootKeyPathSignatureContainer = BaseTaprootKeyPathSignatureContainer<undefined>;\ntype HalfSignedTaprootKeyPathSignatureContainer = BaseTaprootKeyPathSignatureContainer<[Buffer]>;\ntype FullSignedTaprootKeyPathSignatureContainer = BaseTaprootKeyPathSignatureContainer<[Buffer, Buffer]>;\n\ntype TaprootKeyPathSignatureContainer =\n  | UnsignedTaprootKeyPathSignatureContainer\n  | HalfSignedTaprootKeyPathSignatureContainer\n  | FullSignedTaprootKeyPathSignatureContainer;\n\n/**\n * To hold parsed psbt data for p2ms based script types - p2sh, p2wsh, and p2shP2wsh\n */\nexport type ParsedPsbtP2ms = ParsedPubScriptP2ms & SignatureContainer;\n\n/**\n * To hold parsed psbt data for TaprootKeyPathSpend script type.\n */\nexport type ParsedPsbtTaprootKeyPath = ParsedPubScriptTaprootKeyPath & TaprootKeyPathSignatureContainer;\n\n/**\n * To hold parsed psbt data for TaprootScriptPathSpend script path script type.\n */\nexport type ParsedPsbtTaprootScriptPath = ParsedPubScriptTaprootScriptPath &\n  SignatureContainer & {\n    controlBlock: Buffer;\n    leafVersion: number;\n    /** Indicates the level inside the taptree. */\n    scriptPathLevel: number;\n  };\n\nexport type ParsedPsbtTaproot = ParsedPsbtTaprootKeyPath | ParsedPsbtTaprootScriptPath;\n\ntype P2shP2pkSignatureContainer = UnsignedSignatureContainer | HalfSignedSignatureContainer;\n\nexport type ParsedPsbtP2shP2pk = ParsedPubScriptP2shP2pk & P2shP2pkSignatureContainer;\n\ninterface WalletSigner {\n  walletKey: BIP32Interface;\n  rootKey: BIP32Interface;\n}\n\n/**\n * psbt input index and its user, backup, bitgo signatures status\n */\nexport type SignatureValidation = [index: number, sigTriple: Triple<boolean>];\n\nfunction getTaprootSigners(script: Buffer, walletKeys: DerivedWalletKeys): [WalletSigner, WalletSigner] {\n  const parsedPublicKeys = parsePubScript2Of3(script, 'taprootScriptPathSpend').publicKeys;\n  const walletSigners = parsedPublicKeys.map((publicKey) => {\n    const index = walletKeys.publicKeys.findIndex((walletPublicKey) =>\n      toXOnlyPublicKey(walletPublicKey).equals(publicKey)\n    );\n    if (index >= 0) {\n      return { walletKey: walletKeys.triple[index], rootKey: walletKeys.parent.triple[index] };\n    }\n    throw new Error('Taproot public key is not a wallet public key');\n  });\n  return [walletSigners[0], walletSigners[1]];\n}\n\nfunction updatePsbtInput(\n  psbt: UtxoPsbt,\n  inputIndex: number,\n  unspent: WalletUnspent<bigint>,\n  rootWalletKeys: RootWalletKeys\n): void {\n  const input = checkForInput(psbt.data.inputs, inputIndex);\n  const signatureCount = getPsbtInputSignatureCount(input);\n  const scriptType = scriptTypeForChain(unspent.chain);\n  if (signatureCount === 0 && scriptType === 'p2tr') {\n    return;\n  }\n  const walletKeys = rootWalletKeys.deriveForChainAndIndex(unspent.chain, unspent.index);\n\n  if (scriptType === 'p2tr') {\n    if (!Array.isArray(input.tapLeafScript) || input.tapLeafScript.length === 0) {\n      throw new Error('Invalid PSBT state. Missing required fields.');\n    }\n\n    if (input.tapLeafScript.length > 1) {\n      throw new Error('Bitgo only supports a single tap leaf script per input');\n    }\n\n    const [signer, cosigner] = getTaprootSigners(input.tapLeafScript[0].script, walletKeys);\n\n    const leafHash = getLeafHash({\n      publicKeys: walletKeys.publicKeys,\n      signer: signer.walletKey.publicKey,\n      cosigner: cosigner.walletKey.publicKey,\n    });\n\n    psbt.updateInput(inputIndex, {\n      tapBip32Derivation: [signer, cosigner].map((walletSigner) => ({\n        leafHashes: [leafHash],\n        pubkey: toXOnlyPublicKey(walletSigner.walletKey.publicKey),\n        path: rootWalletKeys.getDerivationPath(walletSigner.rootKey, unspent.chain, unspent.index),\n        masterFingerprint: walletSigner.rootKey.fingerprint,\n      })),\n    });\n  } else {\n    if (signatureCount === 0) {\n      const { witnessScript, redeemScript } = createOutputScript2of3(walletKeys.publicKeys, scriptType);\n      if (witnessScript && psbt.data.inputs[inputIndex].witnessScript === undefined) {\n        psbt.updateInput(inputIndex, { witnessScript });\n      }\n      if (redeemScript && psbt.data.inputs[inputIndex].redeemScript === undefined) {\n        psbt.updateInput(inputIndex, { redeemScript });\n      }\n    }\n\n    psbt.updateInput(inputIndex, {\n      bip32Derivation: [0, 1, 2].map((idx) => ({\n        pubkey: walletKeys.triple[idx].publicKey,\n        path: walletKeys.paths[idx],\n        masterFingerprint: rootWalletKeys.triple[idx].fingerprint,\n      })),\n    });\n  }\n}\n\n/**\n * @return PSBT filled with metatdata as per input params tx, unspents and rootWalletKeys.\n * Unsigned PSBT for taproot input with witnessUtxo\n * Unsigned PSBT for other input with witnessUtxo/nonWitnessUtxo, redeemScript/witnessScript, bip32Derivation\n * Signed PSBT for taproot input with witnessUtxo, tapLeafScript, tapBip32Derivation, tapScriptSig\n * Signed PSBT for other input with witnessUtxo/nonWitnessUtxo, redeemScript/witnessScript, bip32Derivation, partialSig\n */\nexport function toWalletPsbt(\n  tx: UtxoTransaction<bigint>,\n  unspents: WalletUnspent<bigint>[],\n  rootWalletKeys: RootWalletKeys\n): UtxoPsbt {\n  const prevOutputs = unspents.map((u) => {\n    assert.notStrictEqual(scriptTypeForChain(u.chain), 'p2trMusig2');\n    return toPrevOutputWithPrevTx(u, tx.network);\n  });\n  const psbt = createPsbtFromTransaction(tx, prevOutputs);\n  unspents.forEach((u, i) => {\n    if (isWalletUnspent(u) && u.index !== undefined) {\n      updatePsbtInput(psbt, i, u, rootWalletKeys);\n    }\n  });\n  return psbt;\n}\n\n/**\n * @param psbt\n * @param inputIndex\n * @param signer\n * @param unspent\n * @return signed PSBT with signer's key for unspent\n */\nexport function signWalletPsbt(\n  psbt: UtxoPsbt,\n  inputIndex: number,\n  signer: BIP32Interface,\n  unspent: WalletUnspent<bigint>\n): void {\n  const scriptType = scriptTypeForChain(unspent.chain);\n  if (scriptType === 'p2tr' || scriptType === 'p2trMusig2') {\n    psbt.signTaprootInputHD(inputIndex, signer);\n  } else {\n    psbt.signInputHD(inputIndex, signer);\n  }\n}\n\n/**\n * @returns script type of the input\n */\nexport function getPsbtInputScriptType(input: PsbtInput): ParsedScriptType {\n  const isP2pk = (script: Buffer) => {\n    try {\n      const chunks = bscript.decompile(script);\n      return (\n        chunks?.length === 2 &&\n        Buffer.isBuffer(chunks[0]) &&\n        bscript.isCanonicalPubKey(chunks[0]) &&\n        chunks[1] === opcodes.OP_CHECKSIG\n      );\n    } catch (e) {\n      return false;\n    }\n  };\n  let scriptType: ParsedScriptType | undefined;\n  if (Buffer.isBuffer(input.redeemScript) && Buffer.isBuffer(input.witnessScript)) {\n    scriptType = 'p2shP2wsh';\n  } else if (Buffer.isBuffer(input.redeemScript)) {\n    scriptType = isP2pk(input.redeemScript) ? 'p2shP2pk' : 'p2sh';\n  } else if (Buffer.isBuffer(input.witnessScript)) {\n    scriptType = 'p2wsh';\n  }\n  if (Array.isArray(input.tapLeafScript) && input.tapLeafScript.length > 0) {\n    if (scriptType) {\n      throw new Error(`Found both ${scriptType} and taprootScriptPath PSBT metadata.`);\n    }\n    if (input.tapLeafScript.length > 1) {\n      throw new Error('Bitgo only supports a single tap leaf script per input.');\n    }\n    scriptType = 'taprootScriptPathSpend';\n  }\n  if (input.tapInternalKey) {\n    if (scriptType) {\n      throw new Error(`Found both ${scriptType} and taprootKeyPath PSBT metadata.`);\n    }\n    scriptType = 'taprootKeyPathSpend';\n  }\n  if (scriptType) {\n    return scriptType;\n  }\n  throw new Error('could not parse input');\n}\n\nfunction parseTaprootKeyPathSignatures(input: PsbtInput): TaprootKeyPathSignatureContainer {\n  const partialSigs = parsePsbtMusig2PartialSigs(input);\n  if (!partialSigs) {\n    return { signatures: undefined, participantPublicKeys: undefined };\n  }\n  const signatures = partialSigs.map((pSig) => pSig.partialSig);\n  const participantPublicKeys = partialSigs.map((pSig) => pSig.participantPubKey);\n  return isTuple<Buffer>(signatures) && isTuple<Buffer>(participantPublicKeys)\n    ? { signatures, participantPublicKeys }\n    : { signatures: [signatures[0]], participantPublicKeys: [participantPublicKeys[0]] };\n}\n\nfunction parsePartialOrTapScriptSignatures(sig: PartialSig[] | TapScriptSig[] | undefined): SignatureContainer {\n  if (!sig?.length) {\n    return { signatures: undefined };\n  }\n  if (sig.length > 2) {\n    throw new Error('unexpected signature count');\n  }\n  const signatures = sig.map((tSig) => tSig.signature);\n  return isTuple<Buffer>(signatures) ? { signatures } : { signatures: [signatures[0]] };\n}\n\nfunction parseSignatures(\n  input: PsbtInput,\n  scriptType: ParsedScriptType\n): SignatureContainer | TaprootKeyPathSignatureContainer {\n  return scriptType === 'taprootKeyPathSpend'\n    ? parseTaprootKeyPathSignatures(input)\n    : scriptType === 'taprootScriptPathSpend'\n    ? parsePartialOrTapScriptSignatures(input.tapScriptSig)\n    : parsePartialOrTapScriptSignatures(input.partialSig);\n}\n\nfunction parseScript(\n  input: PsbtInput,\n  scriptType: ParsedScriptType\n): ParsedPubScriptP2ms | ParsedPubScriptTaproot | ParsedPubScriptP2shP2pk {\n  let pubScript: Buffer | undefined;\n  if (scriptType === 'p2sh' || scriptType === 'p2shP2pk') {\n    pubScript = input.redeemScript;\n  } else if (scriptType === 'p2wsh' || scriptType === 'p2shP2wsh') {\n    pubScript = input.witnessScript;\n  } else if (scriptType === 'taprootScriptPathSpend') {\n    pubScript = input.tapLeafScript ? input.tapLeafScript[0].script : undefined;\n  } else if (scriptType === 'taprootKeyPathSpend') {\n    if (input.witnessUtxo?.script) {\n      pubScript = input.witnessUtxo.script;\n    } else if (input.tapInternalKey && input.tapMerkleRoot) {\n      pubScript = createTaprootOutputScript({ internalPubKey: input.tapInternalKey, taptreeRoot: input.tapMerkleRoot });\n    }\n  }\n  if (!pubScript) {\n    throw new Error(`Invalid PSBT state for ${scriptType}. Missing required fields.`);\n  }\n  return parsePubScript(pubScript, scriptType);\n}\n\n/**\n * @return psbt metadata are parsed as per below conditions.\n * redeemScript/witnessScript/tapLeafScript matches BitGo.\n * signature and public key count matches BitGo.\n * P2SH-P2PK => scriptType, redeemScript, public key, signature.\n * P2SH => scriptType, redeemScript, public keys, signatures.\n * PW2SH => scriptType, witnessScript, public keys, signatures.\n * P2SH-PW2SH => scriptType, redeemScript, witnessScript, public keys, signatures.\n * P2TR and P2TR MUSIG2 script path => scriptType (taprootScriptPathSpend), pubScript (leaf script), controlBlock,\n * scriptPathLevel, leafVersion, public keys, signatures.\n * P2TR MUSIG2 kep path => scriptType (taprootKeyPathSpend), pubScript (scriptPubKey), participant pub keys (signer),\n * public key (tapOutputkey), signatures (partial signer sigs).\n */\nexport function parsePsbtInput(input: PsbtInput): ParsedPsbtP2ms | ParsedPsbtTaproot | ParsedPsbtP2shP2pk {\n  if (isPsbtInputFinalized(input)) {\n    throw new Error('Finalized PSBT parsing is not supported');\n  }\n  const scriptType = getPsbtInputScriptType(input);\n  const parsedPubScript = parseScript(input, scriptType);\n  const signatures = parseSignatures(input, scriptType);\n\n  if (parsedPubScript.scriptType === 'taprootKeyPathSpend' && 'participantPublicKeys' in signatures) {\n    return {\n      ...parsedPubScript,\n      ...signatures,\n      scriptType: parsedPubScript.scriptType,\n    };\n  }\n  if (parsedPubScript.scriptType === 'taprootScriptPathSpend') {\n    if (!input.tapLeafScript) {\n      throw new Error('Invalid PSBT state for taprootScriptPathSpend. Missing required fields.');\n    }\n    const controlBlock = input.tapLeafScript[0].controlBlock;\n    if (!isValidControlBock(controlBlock)) {\n      throw new Error('Invalid PSBT taprootScriptPathSpend controlBlock.');\n    }\n    const scriptPathLevel = calculateScriptPathLevel(controlBlock);\n    const leafVersion = getLeafVersion(controlBlock);\n    return {\n      ...parsedPubScript,\n      ...signatures,\n      scriptType: parsedPubScript.scriptType,\n      controlBlock,\n      scriptPathLevel,\n      leafVersion,\n    };\n  }\n  if (\n    parsedPubScript.scriptType === 'p2sh' ||\n    parsedPubScript.scriptType === 'p2wsh' ||\n    parsedPubScript.scriptType === 'p2shP2wsh'\n  ) {\n    if (parsedPubScript.scriptType === 'p2shP2wsh') {\n      parsedPubScript.redeemScript = input.redeemScript;\n    }\n    return {\n      ...parsedPubScript,\n      ...signatures,\n    };\n  }\n  if (parsedPubScript.scriptType === 'p2shP2pk' && (!signatures.signatures || !isTuple(signatures.signatures))) {\n    // @ts-ignore\n    return {\n      ...parsedPubScript,\n      signatures: signatures.signatures,\n    };\n  }\n  throw new Error('invalid pub script');\n}\n\n/**\n * Converts a parsed script type into an array of script types.\n * @param parsedScriptType - The parsed script type.\n * @returns An array of ScriptType2Of3 values corresponding to the parsed script type.\n */\nexport function toScriptType2Of3s(parsedScriptType: ParsedScriptType2Of3): ScriptType2Of3[] {\n  return parsedScriptType === 'taprootScriptPathSpend'\n    ? ['p2trMusig2', 'p2tr']\n    : parsedScriptType === 'taprootKeyPathSpend'\n    ? ['p2trMusig2']\n    : [parsedScriptType];\n}\n\n/**\n * @returns strictly parse the input and get signature count.\n * unsigned(0), half-signed(1) or fully-signed(2)\n */\nexport function getStrictSignatureCount(input: TxInput | PsbtInput): 0 | 1 | 2 {\n  const calculateSignatureCount = (\n    signatures: [Buffer | 0, Buffer | 0, Buffer | 0] | [Buffer, Buffer] | [Buffer] | undefined\n  ): 0 | 1 | 2 => {\n    const count = signatures ? signatures.filter((s) => !isPlaceholderSignature(s)).length : 0;\n    if (count === 0 || count === 1 || count === 2) {\n      return count;\n    }\n    throw new Error('invalid signature count');\n  };\n\n  if ('hash' in input) {\n    if (input.script?.length || input.witness?.length) {\n      const parsedInput = parseSignatureScript(input);\n      return parsedInput.scriptType === 'taprootKeyPathSpend' ? 2 : calculateSignatureCount(parsedInput.signatures);\n    }\n    return 0;\n  } else {\n    return calculateSignatureCount(parsePsbtInput(input).signatures);\n  }\n}\n\n/**\n * @returns strictly parse input and get signature count for all inputs.\n * 0=unsigned, 1=half-signed or 2=fully-signed\n */\nexport function getStrictSignatureCounts(\n  tx: UtxoPsbt | UtxoTransaction<number | bigint> | PsbtInput[] | TxInput[]\n): (0 | 1 | 2)[] {\n  const inputs = tx instanceof UtxoPsbt ? tx.data.inputs : tx instanceof UtxoTransaction ? tx.ins : tx;\n  return inputs.map((input, _) => getStrictSignatureCount(input));\n}\n\n/**\n * @return true iff inputs array is of PsbtInputType type\n * */\nexport function isPsbtInputArray(inputs: PsbtInput[] | TxInput[]): inputs is PsbtInput[] {\n  return !isTxInputArray(inputs);\n}\n\n/**\n * @return true iff inputs array is of TxInput type\n * */\nexport function isTxInputArray(inputs: PsbtInput[] | TxInput[]): inputs is TxInput[] {\n  assert(!!inputs.length, 'empty inputs array');\n  return 'hash' in inputs[0];\n}\n\n/**\n * @returns true iff given psbt/transaction/tx-input-array/psbt-input-array contains at least one taproot key path spend input\n */\nexport function isTransactionWithKeyPathSpendInput(\n  data: UtxoPsbt | UtxoTransaction<bigint | number> | PsbtInput[] | TxInput[]\n): boolean {\n  const inputs = data instanceof UtxoPsbt ? data.data.inputs : data instanceof UtxoTransaction ? data.ins : data;\n  if (!inputs.length) {\n    return false;\n  }\n  if (isPsbtInputArray(inputs)) {\n    return inputs.some((input, _) => getPsbtInputScriptType(input) === 'taprootKeyPathSpend');\n  }\n  return inputs.some((input, _) => {\n    // If the input is not signed, it cannot be a taprootKeyPathSpend input because you can only\n    // extract a fully signed psbt into a transaction with taprootKeyPathSpend inputs.\n    if (getStrictSignatureCount(input) === 0) {\n      return false;\n    }\n    return parseSignatureScript(input).scriptType === 'taprootKeyPathSpend';\n  });\n}\n\n/**\n * Set the RootWalletKeys as the globalXpubs on the psbt\n *\n * We do all the matching of the (tap)bip32Derivations masterFingerprint to the fingerprint of the\n * extendedPubkey.\n */\nexport function addXpubsToPsbt(psbt: UtxoPsbt, rootWalletKeys: RootWalletKeys): void {\n  const safeRootWalletKeys = new RootWalletKeys(\n    rootWalletKeys.triple.map((bip32) => bip32.neutered()) as Triple<BIP32Interface>,\n    rootWalletKeys.derivationPrefixes\n  );\n  const xPubs = safeRootWalletKeys.triple.map(\n    (bip32): GlobalXpub => ({\n      extendedPubkey: bs58check.decode(bip32.toBase58()),\n      masterFingerprint: bip32.fingerprint,\n      // TODO: BG-73797 - bip174 currently requires m prefix for this to be a valid globalXpub\n      path: 'm',\n    })\n  );\n  psbt.updateGlobal({ globalXpub: xPubs });\n}\n\n/**\n * validates signatures for each 2 of 3 input against user, backup, bitgo keys derived from rootWalletKeys.\n * @returns array of input index and its [is valid user sig exist, is valid backup sig exist, is valid user bitgo exist]\n * For p2shP2pk input, [false, false, false] is returned since it is not a 2 of 3 sig input.\n */\nexport function getSignatureValidationArrayPsbt(psbt: UtxoPsbt, rootWalletKeys: RootWalletKeys): SignatureValidation[] {\n  return psbt.data.inputs.map((input, i) => {\n    const sigValArrayForInput: Triple<boolean> =\n      getPsbtInputScriptType(input) === 'p2shP2pk'\n        ? [false, false, false]\n        : psbt.getSignatureValidationArray(i, { rootNodes: rootWalletKeys.triple });\n    return [i, sigValArrayForInput];\n  });\n}\n\n/**\n * Extracts the half signed transaction from the psbt for p2ms based script types - p2sh, p2wsh, and p2shP2wsh.\n * The purpose is to provide backward compatibility to keyternal (KRS) that only supports network transaction and p2ms script types.\n */\nexport function extractP2msOnlyHalfSignedTx(psbt: UtxoPsbt): UtxoTransaction<bigint> {\n  assert(!!(psbt.data.inputs.length && psbt.data.outputs.length), 'empty inputs or outputs');\n  const tx = psbt.getUnsignedTx();\n\n  function isP2msParsedPsbtInput(\n    parsed: ParsedPsbtP2ms | ParsedPsbtTaproot | ParsedPsbtP2shP2pk\n  ): parsed is ParsedPsbtP2ms {\n    return ['p2sh', 'p2shP2wsh', 'p2wsh'].includes(parsed.scriptType);\n  }\n\n  psbt.data.inputs.forEach((input, i) => {\n    const parsed = parsePsbtInput(input);\n    assert(isP2msParsedPsbtInput(parsed), `unsupported script type ${parsed.scriptType}`);\n    assert(input.partialSig?.length === 1, `unexpected signature count ${input.partialSig?.length}`);\n    const [partialSig] = input.partialSig;\n    assert(\n      input.sighashType !== undefined && input.sighashType === bscript.signature.decode(partialSig.signature).hashType,\n      'signature sighash does not match input sighash type'\n    );\n\n    // type casting is to address the invalid type checking in payments.p2ms\n    const signatures = parsed.publicKeys.map((pk) =>\n      partialSig.pubkey.equals(pk) ? partialSig.signature : (ops.OP_0 as unknown as Buffer)\n    );\n\n    const isP2SH = !!parsed.redeemScript;\n    const isP2WSH = !!parsed.witnessScript;\n\n    const payment = payments.p2ms({ output: parsed.pubScript, signatures }, { validate: false, allowIncomplete: true });\n    const p2wsh = isP2WSH ? payments.p2wsh({ redeem: payment }) : undefined;\n    const p2sh = isP2SH ? payments.p2sh({ redeem: p2wsh || payment }) : undefined;\n\n    if (p2sh?.input) {\n      tx.setInputScript(i, p2sh.input);\n    }\n    if (p2wsh?.witness) {\n      tx.setWitness(i, p2wsh.witness);\n    }\n  });\n\n  return tx;\n}\n\n/**\n * Clones the psbt without nonWitnessUtxo for non-segwit inputs and witnessUtxo is added instead.\n * It is not BIP-174 compliant, so use it carefully.\n */\nexport function clonePsbtWithoutNonWitnessUtxo(psbt: UtxoPsbt): UtxoPsbt {\n  const newPsbt = createPsbtFromHex(psbt.toHex(), psbt.network);\n  const txInputs = psbt.txInputs;\n\n  psbt.data.inputs.forEach((input, i) => {\n    if (input.nonWitnessUtxo && !input.witnessUtxo) {\n      const tx = createTransactionFromBuffer(input.nonWitnessUtxo, psbt.network, { amountType: 'bigint' });\n      if (!txInputs[i].hash.equals(tx.getHash())) {\n        throw new Error(`Non-witness UTXO hash for input #${i} doesn't match the hash specified in the prevout`);\n      }\n      newPsbt.data.inputs[i].witnessUtxo = tx.outs[txInputs[i].index];\n    }\n    delete newPsbt.data.inputs[i].nonWitnessUtxo;\n  });\n\n  return newPsbt;\n}\n\n/**\n * Returns true if there are non-segwit inputs in the PSBT that do not contain the\n * nonWitnessUtxo.\n *\n * isPsbtLite(clonePsbtWithoutNonWitnessUtxo(psbt)) === true\n *\n * @param psbt\n */\nexport function isPsbtLite(psbt: UtxoPsbt): boolean {\n  let isFull = true;\n  const nonSegwitInputTypes = ['p2shP2pk', 'p2sh'];\n  psbt.data.inputs.forEach((input) => {\n    if (isFull && nonSegwitInputTypes.includes(getPsbtInputScriptType(input))) {\n      isFull = !!input.nonWitnessUtxo;\n    }\n  });\n  return !isFull;\n}\n\n/**\n * Deletes witnessUtxo for non-segwit inputs to make the PSBT BIP-174 compliant.\n */\nexport function deleteWitnessUtxoForNonSegwitInputs(psbt: UtxoPsbt): void {\n  psbt.data.inputs.forEach((input, i) => {\n    const scriptType = getPsbtInputScriptType(input);\n    if (scriptType === 'p2sh' || scriptType === 'p2shP2pk') {\n      delete input.witnessUtxo;\n    }\n  });\n}\n"]}
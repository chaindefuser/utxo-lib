{"version":3,"file":"/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/nonStandardHalfSigned.ts","sources":["/Users/qroc/Code/hapi/chaindefuser/utxo-lib/src/bitgo/nonStandardHalfSigned.ts"],"names":[],"mappings":";;AAQA,wCAgDC;AAxDD,iCAAiC;AACjC,uCAAuC;AACvC,2BAA2D;AAE3D;;;GAGG;AACH,SAAgB,cAAc,CAAC,KAAc,EAAE,cAAsB;IACnE,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC;QACxC,0BAA0B;QAC1B,MAAM,IAAI,KAAK,CAAC,mDAAmD,CAAC,CAAC;IACvE,CAAC;IAED,IAAI,mBAAmB,CAAC;IACxB,IAAI,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QAC9C,mBAAmB,GAAG,KAAK,CAAC,OAAO,CAAC;IACtC,CAAC;SAAM,CAAC;QACN,mBAAmB,GAAG,UAAO,CAAC,SAAS,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACxD,CAAC;IAED,mDAAmD;IACnD,4BAA4B;IAC5B,IAAI,CAAC,mBAAmB,IAAI,mBAAmB,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;QAC7D,0BAA0B;QAC1B,OAAO;IACT,CAAC;IAED,MAAM,CAAC,GAAG,EAAE,eAAe,EAAE,SAAS,CAAC,GAAG,mBAAmB,CAAC;IAC9D,IAAI,GAAG,KAAK,OAAO,CAAC,IAAI,IAAI,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,CAAC,EAAE,CAAC;QACxE,0BAA0B;QAC1B,OAAO;IACT,CAAC;IAED,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,SAAS,CAAC,EAAE,CAAC;QAChC,0BAA0B;QAC1B,OAAO;IACT,CAAC;IAED,IAAI,YAAQ,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,YAAQ,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;QACvD,0BAA0B;QAC1B,OAAO;IACT,CAAC;IAED,MAAM,eAAe,GAAG;QACtB,GAAG;QACH,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,KAAK,cAAc,CAAC,CAAC,CAAC,eAAe,CAAC,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;QACnF,SAAS;KACV,CAAC;IAEF,IAAI,KAAK,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;QACzB,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC3D,KAAK,CAAC,OAAO,GAAG,eAA2B,CAAC;IAC9C,CAAC;SAAM,CAAC;QACN,KAAK,CAAC,MAAM,GAAG,UAAO,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;IAClD,CAAC;AACH,CAAC","sourcesContent":["import * as assert from 'assert';\nimport * as opcodes from 'bitcoin-ops';\nimport { classify, script as bscript, TxInput } from '../';\n\n/**\n * @param input - Input of non-standard half-signed transaction created with `tx.build()` instead of `tx.buildIncomplete()`.\n * @param signatureIndex - Position to map the existing signatures to. Other signatures will be padded with OP_0.\n */\nexport function padInputScript(input: TxInput, signatureIndex: number): void {\n  if (![0, 1, 2].includes(signatureIndex)) {\n    /* istanbul ignore next */\n    throw new Error(`invalid signature index: must be one of [0, 1, 2]`);\n  }\n\n  let decompiledSigScript;\n  if (input.witness && input.witness.length > 0) {\n    decompiledSigScript = input.witness;\n  } else {\n    decompiledSigScript = bscript.decompile(input.script);\n  }\n\n  // The shape of a non-standard half-signed input is\n  //   OP_0 <signature> <p2ms>\n  if (!decompiledSigScript || decompiledSigScript.length !== 3) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  const [op0, signatureBuffer, sigScript] = decompiledSigScript;\n  if (op0 !== opcodes.OP_0 && !(Buffer.isBuffer(op0) && op0.length === 0)) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  if (!Buffer.isBuffer(sigScript)) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  if (classify.output(sigScript) !== classify.types.P2MS) {\n    /* istanbul ignore next */\n    return;\n  }\n\n  const paddedSigScript = [\n    op0,\n    ...[0, 1, 2].map((i) => (i === signatureIndex ? signatureBuffer : Buffer.from([]))),\n    sigScript,\n  ];\n\n  if (input.witness.length) {\n    paddedSigScript.forEach((b) => assert(Buffer.isBuffer(b)));\n    input.witness = paddedSigScript as Buffer[];\n  } else {\n    input.script = bscript.compile(paddedSigScript);\n  }\n}\n"]}